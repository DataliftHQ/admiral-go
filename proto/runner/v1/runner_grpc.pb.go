// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.1
// - protoc             (unknown)
// source: runner/v1/runner.proto

package runnerv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	RunnerAPI_CreateRunner_FullMethodName      = "/admiral.api.runner.v1.RunnerAPI/CreateRunner"
	RunnerAPI_GetRunner_FullMethodName         = "/admiral.api.runner.v1.RunnerAPI/GetRunner"
	RunnerAPI_ListRunners_FullMethodName       = "/admiral.api.runner.v1.RunnerAPI/ListRunners"
	RunnerAPI_UpdateRunner_FullMethodName      = "/admiral.api.runner.v1.RunnerAPI/UpdateRunner"
	RunnerAPI_DeleteRunner_FullMethodName      = "/admiral.api.runner.v1.RunnerAPI/DeleteRunner"
	RunnerAPI_CreateRunnerToken_FullMethodName = "/admiral.api.runner.v1.RunnerAPI/CreateRunnerToken"
	RunnerAPI_ListRunnerTokens_FullMethodName  = "/admiral.api.runner.v1.RunnerAPI/ListRunnerTokens"
	RunnerAPI_GetRunnerToken_FullMethodName    = "/admiral.api.runner.v1.RunnerAPI/GetRunnerToken"
	RunnerAPI_RevokeRunnerToken_FullMethodName = "/admiral.api.runner.v1.RunnerAPI/RevokeRunnerToken"
)

// RunnerAPIClient is the client API for RunnerAPI service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// RunnerAPI manages runners — execution environments for Infrastructure as Code
// (IaC) and workflow jobs.
//
// A runner represents a credential and execution boundary. Each runner is backed
// by a controller process deployed to a Kubernetes cluster. The controller holds
// an Agent Token (AGT), registers with AgentAPI.RegisterAgent on boot, and
// spawns ephemeral pods to execute jobs (e.g., terraform plan/apply).
//
// Administrators create runners via CreateRunner, which returns an AGT for
// deploying the controller. Labels on the runner are used for job routing in
// the UI — for example, selecting which runner should execute a Terraform module
// based on team or environment labels.
//
// Different teams or cloud accounts should use separate runners to maintain
// credential isolation (e.g., via Workload Identity in GKE).
type RunnerAPIClient interface {
	// CreateRunner creates a new runner within the caller's tenant and generates
	// an initial Agent Token (AGT) for the controller. The response includes a
	// `plain_text_token` — the raw AGT secret shown exactly once.
	//
	// Deploy this token to the controller (e.g., via Helm values or a Kubernetes
	// Secret). The controller uses it to authenticate with AgentAPI.RegisterAgent
	// on first boot.
	//
	// Scope: `runners:write`
	CreateRunner(ctx context.Context, in *CreateRunnerRequest, opts ...grpc.CallOption) (*CreateRunnerResponse, error)
	// GetRunner retrieves a runner by ID.
	//
	// Scope: `runners:read`
	GetRunner(ctx context.Context, in *GetRunnerRequest, opts ...grpc.CallOption) (*GetRunnerResponse, error)
	// ListRunners returns a paginated list of runners within the caller's tenant.
	//
	// Scope: `runners:read`
	ListRunners(ctx context.Context, in *ListRunnersRequest, opts ...grpc.CallOption) (*ListRunnersResponse, error)
	// UpdateRunner updates a runner's mutable fields (display name, labels).
	// Use the `update_mask` to specify which fields to update.
	//
	// Scope: `runners:write`
	UpdateRunner(ctx context.Context, in *UpdateRunnerRequest, opts ...grpc.CallOption) (*UpdateRunnerResponse, error)
	// DeleteRunner permanently deletes a runner, revokes all associated Agent
	// Tokens, and removes the agent record. Running jobs are not interrupted
	// but no new jobs will be assigned to this runner.
	//
	// Scope: `runners:write`
	DeleteRunner(ctx context.Context, in *DeleteRunnerRequest, opts ...grpc.CallOption) (*DeleteRunnerResponse, error)
	// CreateRunnerToken creates a new Agent Token (AGT) bound to the specified
	// runner. Scopes are auto-assigned and cannot be overridden. The response
	// includes the raw token secret, which is shown exactly once.
	//
	// Use this to create additional AGTs for an existing runner (e.g., for
	// zero-downtime token rotation). The initial AGT is created automatically
	// by CreateRunner.
	//
	// Scope: `runners:write`
	CreateRunnerToken(ctx context.Context, in *CreateRunnerTokenRequest, opts ...grpc.CallOption) (*CreateRunnerTokenResponse, error)
	// ListRunnerTokens returns a paginated list of AGTs bound to the specified
	// runner. Token secrets are never included.
	//
	// Scope: `runners:read`
	ListRunnerTokens(ctx context.Context, in *ListRunnerTokensRequest, opts ...grpc.CallOption) (*ListRunnerTokensResponse, error)
	// GetRunnerToken retrieves a single AGT by ID.
	// Returns metadata only — the token secret is never included.
	//
	// Scope: `runners:read`
	GetRunnerToken(ctx context.Context, in *GetRunnerTokenRequest, opts ...grpc.CallOption) (*GetRunnerTokenResponse, error)
	// RevokeRunnerToken permanently revokes an AGT bound to this runner.
	// The agent will receive a 401 on its next request. If this is the only
	// active AGT for the runner, the agent will become disconnected.
	//
	// Scope: `runners:write`
	RevokeRunnerToken(ctx context.Context, in *RevokeRunnerTokenRequest, opts ...grpc.CallOption) (*RevokeRunnerTokenResponse, error)
}

type runnerAPIClient struct {
	cc grpc.ClientConnInterface
}

func NewRunnerAPIClient(cc grpc.ClientConnInterface) RunnerAPIClient {
	return &runnerAPIClient{cc}
}

func (c *runnerAPIClient) CreateRunner(ctx context.Context, in *CreateRunnerRequest, opts ...grpc.CallOption) (*CreateRunnerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateRunnerResponse)
	err := c.cc.Invoke(ctx, RunnerAPI_CreateRunner_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerAPIClient) GetRunner(ctx context.Context, in *GetRunnerRequest, opts ...grpc.CallOption) (*GetRunnerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRunnerResponse)
	err := c.cc.Invoke(ctx, RunnerAPI_GetRunner_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerAPIClient) ListRunners(ctx context.Context, in *ListRunnersRequest, opts ...grpc.CallOption) (*ListRunnersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListRunnersResponse)
	err := c.cc.Invoke(ctx, RunnerAPI_ListRunners_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerAPIClient) UpdateRunner(ctx context.Context, in *UpdateRunnerRequest, opts ...grpc.CallOption) (*UpdateRunnerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateRunnerResponse)
	err := c.cc.Invoke(ctx, RunnerAPI_UpdateRunner_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerAPIClient) DeleteRunner(ctx context.Context, in *DeleteRunnerRequest, opts ...grpc.CallOption) (*DeleteRunnerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteRunnerResponse)
	err := c.cc.Invoke(ctx, RunnerAPI_DeleteRunner_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerAPIClient) CreateRunnerToken(ctx context.Context, in *CreateRunnerTokenRequest, opts ...grpc.CallOption) (*CreateRunnerTokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateRunnerTokenResponse)
	err := c.cc.Invoke(ctx, RunnerAPI_CreateRunnerToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerAPIClient) ListRunnerTokens(ctx context.Context, in *ListRunnerTokensRequest, opts ...grpc.CallOption) (*ListRunnerTokensResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListRunnerTokensResponse)
	err := c.cc.Invoke(ctx, RunnerAPI_ListRunnerTokens_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerAPIClient) GetRunnerToken(ctx context.Context, in *GetRunnerTokenRequest, opts ...grpc.CallOption) (*GetRunnerTokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRunnerTokenResponse)
	err := c.cc.Invoke(ctx, RunnerAPI_GetRunnerToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runnerAPIClient) RevokeRunnerToken(ctx context.Context, in *RevokeRunnerTokenRequest, opts ...grpc.CallOption) (*RevokeRunnerTokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RevokeRunnerTokenResponse)
	err := c.cc.Invoke(ctx, RunnerAPI_RevokeRunnerToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RunnerAPIServer is the server API for RunnerAPI service.
// All implementations should embed UnimplementedRunnerAPIServer
// for forward compatibility.
//
// RunnerAPI manages runners — execution environments for Infrastructure as Code
// (IaC) and workflow jobs.
//
// A runner represents a credential and execution boundary. Each runner is backed
// by a controller process deployed to a Kubernetes cluster. The controller holds
// an Agent Token (AGT), registers with AgentAPI.RegisterAgent on boot, and
// spawns ephemeral pods to execute jobs (e.g., terraform plan/apply).
//
// Administrators create runners via CreateRunner, which returns an AGT for
// deploying the controller. Labels on the runner are used for job routing in
// the UI — for example, selecting which runner should execute a Terraform module
// based on team or environment labels.
//
// Different teams or cloud accounts should use separate runners to maintain
// credential isolation (e.g., via Workload Identity in GKE).
type RunnerAPIServer interface {
	// CreateRunner creates a new runner within the caller's tenant and generates
	// an initial Agent Token (AGT) for the controller. The response includes a
	// `plain_text_token` — the raw AGT secret shown exactly once.
	//
	// Deploy this token to the controller (e.g., via Helm values or a Kubernetes
	// Secret). The controller uses it to authenticate with AgentAPI.RegisterAgent
	// on first boot.
	//
	// Scope: `runners:write`
	CreateRunner(context.Context, *CreateRunnerRequest) (*CreateRunnerResponse, error)
	// GetRunner retrieves a runner by ID.
	//
	// Scope: `runners:read`
	GetRunner(context.Context, *GetRunnerRequest) (*GetRunnerResponse, error)
	// ListRunners returns a paginated list of runners within the caller's tenant.
	//
	// Scope: `runners:read`
	ListRunners(context.Context, *ListRunnersRequest) (*ListRunnersResponse, error)
	// UpdateRunner updates a runner's mutable fields (display name, labels).
	// Use the `update_mask` to specify which fields to update.
	//
	// Scope: `runners:write`
	UpdateRunner(context.Context, *UpdateRunnerRequest) (*UpdateRunnerResponse, error)
	// DeleteRunner permanently deletes a runner, revokes all associated Agent
	// Tokens, and removes the agent record. Running jobs are not interrupted
	// but no new jobs will be assigned to this runner.
	//
	// Scope: `runners:write`
	DeleteRunner(context.Context, *DeleteRunnerRequest) (*DeleteRunnerResponse, error)
	// CreateRunnerToken creates a new Agent Token (AGT) bound to the specified
	// runner. Scopes are auto-assigned and cannot be overridden. The response
	// includes the raw token secret, which is shown exactly once.
	//
	// Use this to create additional AGTs for an existing runner (e.g., for
	// zero-downtime token rotation). The initial AGT is created automatically
	// by CreateRunner.
	//
	// Scope: `runners:write`
	CreateRunnerToken(context.Context, *CreateRunnerTokenRequest) (*CreateRunnerTokenResponse, error)
	// ListRunnerTokens returns a paginated list of AGTs bound to the specified
	// runner. Token secrets are never included.
	//
	// Scope: `runners:read`
	ListRunnerTokens(context.Context, *ListRunnerTokensRequest) (*ListRunnerTokensResponse, error)
	// GetRunnerToken retrieves a single AGT by ID.
	// Returns metadata only — the token secret is never included.
	//
	// Scope: `runners:read`
	GetRunnerToken(context.Context, *GetRunnerTokenRequest) (*GetRunnerTokenResponse, error)
	// RevokeRunnerToken permanently revokes an AGT bound to this runner.
	// The agent will receive a 401 on its next request. If this is the only
	// active AGT for the runner, the agent will become disconnected.
	//
	// Scope: `runners:write`
	RevokeRunnerToken(context.Context, *RevokeRunnerTokenRequest) (*RevokeRunnerTokenResponse, error)
}

// UnimplementedRunnerAPIServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRunnerAPIServer struct{}

func (UnimplementedRunnerAPIServer) CreateRunner(context.Context, *CreateRunnerRequest) (*CreateRunnerResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateRunner not implemented")
}
func (UnimplementedRunnerAPIServer) GetRunner(context.Context, *GetRunnerRequest) (*GetRunnerResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetRunner not implemented")
}
func (UnimplementedRunnerAPIServer) ListRunners(context.Context, *ListRunnersRequest) (*ListRunnersResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListRunners not implemented")
}
func (UnimplementedRunnerAPIServer) UpdateRunner(context.Context, *UpdateRunnerRequest) (*UpdateRunnerResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateRunner not implemented")
}
func (UnimplementedRunnerAPIServer) DeleteRunner(context.Context, *DeleteRunnerRequest) (*DeleteRunnerResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteRunner not implemented")
}
func (UnimplementedRunnerAPIServer) CreateRunnerToken(context.Context, *CreateRunnerTokenRequest) (*CreateRunnerTokenResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateRunnerToken not implemented")
}
func (UnimplementedRunnerAPIServer) ListRunnerTokens(context.Context, *ListRunnerTokensRequest) (*ListRunnerTokensResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListRunnerTokens not implemented")
}
func (UnimplementedRunnerAPIServer) GetRunnerToken(context.Context, *GetRunnerTokenRequest) (*GetRunnerTokenResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetRunnerToken not implemented")
}
func (UnimplementedRunnerAPIServer) RevokeRunnerToken(context.Context, *RevokeRunnerTokenRequest) (*RevokeRunnerTokenResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RevokeRunnerToken not implemented")
}
func (UnimplementedRunnerAPIServer) testEmbeddedByValue() {}

// UnsafeRunnerAPIServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RunnerAPIServer will
// result in compilation errors.
type UnsafeRunnerAPIServer interface {
	mustEmbedUnimplementedRunnerAPIServer()
}

func RegisterRunnerAPIServer(s grpc.ServiceRegistrar, srv RunnerAPIServer) {
	// If the following call panics, it indicates UnimplementedRunnerAPIServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&RunnerAPI_ServiceDesc, srv)
}

func _RunnerAPI_CreateRunner_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRunnerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerAPIServer).CreateRunner(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RunnerAPI_CreateRunner_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerAPIServer).CreateRunner(ctx, req.(*CreateRunnerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RunnerAPI_GetRunner_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRunnerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerAPIServer).GetRunner(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RunnerAPI_GetRunner_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerAPIServer).GetRunner(ctx, req.(*GetRunnerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RunnerAPI_ListRunners_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRunnersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerAPIServer).ListRunners(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RunnerAPI_ListRunners_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerAPIServer).ListRunners(ctx, req.(*ListRunnersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RunnerAPI_UpdateRunner_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRunnerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerAPIServer).UpdateRunner(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RunnerAPI_UpdateRunner_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerAPIServer).UpdateRunner(ctx, req.(*UpdateRunnerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RunnerAPI_DeleteRunner_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRunnerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerAPIServer).DeleteRunner(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RunnerAPI_DeleteRunner_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerAPIServer).DeleteRunner(ctx, req.(*DeleteRunnerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RunnerAPI_CreateRunnerToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRunnerTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerAPIServer).CreateRunnerToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RunnerAPI_CreateRunnerToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerAPIServer).CreateRunnerToken(ctx, req.(*CreateRunnerTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RunnerAPI_ListRunnerTokens_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRunnerTokensRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerAPIServer).ListRunnerTokens(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RunnerAPI_ListRunnerTokens_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerAPIServer).ListRunnerTokens(ctx, req.(*ListRunnerTokensRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RunnerAPI_GetRunnerToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRunnerTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerAPIServer).GetRunnerToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RunnerAPI_GetRunnerToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerAPIServer).GetRunnerToken(ctx, req.(*GetRunnerTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RunnerAPI_RevokeRunnerToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RevokeRunnerTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunnerAPIServer).RevokeRunnerToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RunnerAPI_RevokeRunnerToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunnerAPIServer).RevokeRunnerToken(ctx, req.(*RevokeRunnerTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RunnerAPI_ServiceDesc is the grpc.ServiceDesc for RunnerAPI service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RunnerAPI_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "admiral.api.runner.v1.RunnerAPI",
	HandlerType: (*RunnerAPIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateRunner",
			Handler:    _RunnerAPI_CreateRunner_Handler,
		},
		{
			MethodName: "GetRunner",
			Handler:    _RunnerAPI_GetRunner_Handler,
		},
		{
			MethodName: "ListRunners",
			Handler:    _RunnerAPI_ListRunners_Handler,
		},
		{
			MethodName: "UpdateRunner",
			Handler:    _RunnerAPI_UpdateRunner_Handler,
		},
		{
			MethodName: "DeleteRunner",
			Handler:    _RunnerAPI_DeleteRunner_Handler,
		},
		{
			MethodName: "CreateRunnerToken",
			Handler:    _RunnerAPI_CreateRunnerToken_Handler,
		},
		{
			MethodName: "ListRunnerTokens",
			Handler:    _RunnerAPI_ListRunnerTokens_Handler,
		},
		{
			MethodName: "GetRunnerToken",
			Handler:    _RunnerAPI_GetRunnerToken_Handler,
		},
		{
			MethodName: "RevokeRunnerToken",
			Handler:    _RunnerAPI_RevokeRunnerToken_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "runner/v1/runner.proto",
}
