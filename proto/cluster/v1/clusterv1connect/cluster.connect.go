// Code generated by protoc-gen-connect-go. DO NOT EDIT.
//
// Source: cluster/v1/cluster.proto

package clusterv1connect

import (
	connect "connectrpc.com/connect"
	context "context"
	errors "errors"
	v1 "go.admiral.io/sdk/proto/cluster/v1"
	http "net/http"
	strings "strings"
)

// This is a compile-time assertion to ensure that this generated file and the connect package are
// compatible. If you get a compiler error that this constant is not defined, this code was
// generated with a version of connect newer than the one compiled into your binary. You can fix the
// problem by either regenerating this code with an older version of connect or updating the connect
// version compiled into your binary.
const _ = connect.IsAtLeastVersion1_13_0

const (
	// ClusterAPIName is the fully-qualified name of the ClusterAPI service.
	ClusterAPIName = "admiral.api.cluster.v1.ClusterAPI"
)

// These constants are the fully-qualified names of the RPCs defined in this package. They're
// exposed at runtime as Spec.Procedure and as the final two segments of the HTTP route.
//
// Note that these are different from the fully-qualified method names used by
// google.golang.org/protobuf/reflect/protoreflect. To convert from these constants to
// reflection-formatted method names, remove the leading slash and convert the remaining slash to a
// period.
const (
	// ClusterAPICreateClusterProcedure is the fully-qualified name of the ClusterAPI's CreateCluster
	// RPC.
	ClusterAPICreateClusterProcedure = "/admiral.api.cluster.v1.ClusterAPI/CreateCluster"
	// ClusterAPIGetClusterProcedure is the fully-qualified name of the ClusterAPI's GetCluster RPC.
	ClusterAPIGetClusterProcedure = "/admiral.api.cluster.v1.ClusterAPI/GetCluster"
	// ClusterAPIGetClusterStatusProcedure is the fully-qualified name of the ClusterAPI's
	// GetClusterStatus RPC.
	ClusterAPIGetClusterStatusProcedure = "/admiral.api.cluster.v1.ClusterAPI/GetClusterStatus"
	// ClusterAPIListClustersProcedure is the fully-qualified name of the ClusterAPI's ListClusters RPC.
	ClusterAPIListClustersProcedure = "/admiral.api.cluster.v1.ClusterAPI/ListClusters"
	// ClusterAPIUpdateClusterProcedure is the fully-qualified name of the ClusterAPI's UpdateCluster
	// RPC.
	ClusterAPIUpdateClusterProcedure = "/admiral.api.cluster.v1.ClusterAPI/UpdateCluster"
	// ClusterAPIDeleteClusterProcedure is the fully-qualified name of the ClusterAPI's DeleteCluster
	// RPC.
	ClusterAPIDeleteClusterProcedure = "/admiral.api.cluster.v1.ClusterAPI/DeleteCluster"
	// ClusterAPICreateClusterTokenProcedure is the fully-qualified name of the ClusterAPI's
	// CreateClusterToken RPC.
	ClusterAPICreateClusterTokenProcedure = "/admiral.api.cluster.v1.ClusterAPI/CreateClusterToken"
	// ClusterAPIListClusterTokensProcedure is the fully-qualified name of the ClusterAPI's
	// ListClusterTokens RPC.
	ClusterAPIListClusterTokensProcedure = "/admiral.api.cluster.v1.ClusterAPI/ListClusterTokens"
	// ClusterAPIGetClusterTokenProcedure is the fully-qualified name of the ClusterAPI's
	// GetClusterToken RPC.
	ClusterAPIGetClusterTokenProcedure = "/admiral.api.cluster.v1.ClusterAPI/GetClusterToken"
	// ClusterAPIRevokeClusterTokenProcedure is the fully-qualified name of the ClusterAPI's
	// RevokeClusterToken RPC.
	ClusterAPIRevokeClusterTokenProcedure = "/admiral.api.cluster.v1.ClusterAPI/RevokeClusterToken"
	// ClusterAPIReportClusterStatusProcedure is the fully-qualified name of the ClusterAPI's
	// ReportClusterStatus RPC.
	ClusterAPIReportClusterStatusProcedure = "/admiral.api.cluster.v1.ClusterAPI/ReportClusterStatus"
	// ClusterAPIListWorkloadsProcedure is the fully-qualified name of the ClusterAPI's ListWorkloads
	// RPC.
	ClusterAPIListWorkloadsProcedure = "/admiral.api.cluster.v1.ClusterAPI/ListWorkloads"
	// ClusterAPIReportWorkloadStatusProcedure is the fully-qualified name of the ClusterAPI's
	// ReportWorkloadStatus RPC.
	ClusterAPIReportWorkloadStatusProcedure = "/admiral.api.cluster.v1.ClusterAPI/ReportWorkloadStatus"
)

// ClusterAPIClient is a client for the admiral.api.cluster.v1.ClusterAPI service.
type ClusterAPIClient interface {
	// CreateCluster creates a new cluster record within the caller's tenant and
	// generates an initial Agent Token (AGT) for the K8s agent. The cluster
	// starts in PENDING status until an agent registers against it.
	//
	// The response includes a `plain_text_token` — the raw AGT secret shown
	// exactly once. Deploy this token to the K8s agent (e.g., via Helm values
	// or a Kubernetes Secret). The agent uses it to authenticate with
	// AgentAPI.RegisterAgent on first boot.
	//
	// Scope: `clusters:write`
	CreateCluster(context.Context, *connect.Request[v1.CreateClusterRequest]) (*connect.Response[v1.CreateClusterResponse], error)
	// GetCluster retrieves a cluster by ID.
	//
	// Returns the Cluster record with its server-derived health_status. For
	// detailed telemetry (node counts, resource usage, workload summary), use
	// GetClusterStatus instead.
	//
	// Scope: `clusters:read`
	GetCluster(context.Context, *connect.Request[v1.GetClusterRequest]) (*connect.Response[v1.GetClusterResponse], error)
	// GetClusterStatus retrieves the current telemetry snapshot for a cluster.
	// Returns the latest metrics pushed by the agent, along with server-derived
	// health status and workload summary counts.
	//
	// Returns NOT_FOUND if the cluster does not exist. If the cluster exists but
	// no agent has reported telemetry yet, the response will have health_status
	// PENDING and no status message.
	//
	// Scope: `clusters:read`
	GetClusterStatus(context.Context, *connect.Request[v1.GetClusterStatusRequest]) (*connect.Response[v1.GetClusterStatusResponse], error)
	// ListClusters returns a paginated list of clusters within the caller's tenant.
	//
	// Scope: `clusters:read`
	ListClusters(context.Context, *connect.Request[v1.ListClustersRequest]) (*connect.Response[v1.ListClustersResponse], error)
	// UpdateCluster updates a cluster's mutable fields (display name, labels).
	// Use the `update_mask` to specify which fields to update.
	//
	// Scope: `clusters:write`
	UpdateCluster(context.Context, *connect.Request[v1.UpdateClusterRequest]) (*connect.Response[v1.UpdateClusterResponse], error)
	// DeleteCluster permanently deletes a cluster record and revokes all
	// associated agent tokens. This action cannot be undone.
	//
	// Scope: `clusters:write`
	DeleteCluster(context.Context, *connect.Request[v1.DeleteClusterRequest]) (*connect.Response[v1.DeleteClusterResponse], error)
	// CreateClusterToken creates a new Agent Token (AGT) bound to the specified
	// cluster. Scopes are auto-assigned and cannot be overridden. The response
	// includes the raw token secret, which is shown exactly once.
	//
	// Use this to create additional AGTs for an existing cluster (e.g., for
	// zero-downtime token rotation). The initial AGT is created automatically
	// by CreateCluster.
	//
	// Scope: `clusters:write`
	CreateClusterToken(context.Context, *connect.Request[v1.CreateClusterTokenRequest]) (*connect.Response[v1.CreateClusterTokenResponse], error)
	// ListClusterTokens returns a paginated list of AGTs bound to the specified
	// cluster. Token secrets are never included.
	//
	// Scope: `clusters:read`
	ListClusterTokens(context.Context, *connect.Request[v1.ListClusterTokensRequest]) (*connect.Response[v1.ListClusterTokensResponse], error)
	// GetClusterToken retrieves a single AGT by ID.
	// Returns metadata only — the token secret is never included.
	//
	// Scope: `clusters:read`
	GetClusterToken(context.Context, *connect.Request[v1.GetClusterTokenRequest]) (*connect.Response[v1.GetClusterTokenResponse], error)
	// RevokeClusterToken permanently revokes an AGT bound to this cluster.
	// The agent will receive a 401 on its next request. If this is the only
	// active AGT for the cluster, the agent will become disconnected.
	//
	// Scope: `clusters:write`
	RevokeClusterToken(context.Context, *connect.Request[v1.RevokeClusterTokenRequest]) (*connect.Response[v1.RevokeClusterTokenResponse], error)
	// ReportClusterStatus receives a combined telemetry snapshot from a K8s agent.
	// The payload includes cluster-level metrics, per-workload status, and
	// Kubernetes events. Admiral splits this into three storage tiers on receipt.
	//
	// This endpoint is agent-facing and restricted to agent tokens.
	//
	// Scope: `clusters:status` | Token types: `agt`
	ReportClusterStatus(context.Context, *connect.Request[v1.ReportClusterStatusRequest]) (*connect.Response[v1.ReportClusterStatusResponse], error)
	// ListWorkloads returns a paginated list of workloads running in a specific cluster.
	//
	// Scope: `clusters:read`
	ListWorkloads(context.Context, *connect.Request[v1.ListWorkloadsRequest]) (*connect.Response[v1.ListWorkloadsResponse], error)
	// ReportWorkloadStatus receives workload-only telemetry from a K8s agent.
	// Used for incremental workload updates between full cluster status pushes.
	//
	// This endpoint is agent-facing and restricted to agent tokens.
	//
	// Scope: `clusters:status` | Token types: `agt`
	ReportWorkloadStatus(context.Context, *connect.Request[v1.ReportWorkloadStatusRequest]) (*connect.Response[v1.ReportWorkloadStatusResponse], error)
}

// NewClusterAPIClient constructs a client for the admiral.api.cluster.v1.ClusterAPI service. By
// default, it uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses,
// and sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the
// connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewClusterAPIClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) ClusterAPIClient {
	baseURL = strings.TrimRight(baseURL, "/")
	clusterAPIMethods := v1.File_cluster_v1_cluster_proto.Services().ByName("ClusterAPI").Methods()
	return &clusterAPIClient{
		createCluster: connect.NewClient[v1.CreateClusterRequest, v1.CreateClusterResponse](
			httpClient,
			baseURL+ClusterAPICreateClusterProcedure,
			connect.WithSchema(clusterAPIMethods.ByName("CreateCluster")),
			connect.WithClientOptions(opts...),
		),
		getCluster: connect.NewClient[v1.GetClusterRequest, v1.GetClusterResponse](
			httpClient,
			baseURL+ClusterAPIGetClusterProcedure,
			connect.WithSchema(clusterAPIMethods.ByName("GetCluster")),
			connect.WithClientOptions(opts...),
		),
		getClusterStatus: connect.NewClient[v1.GetClusterStatusRequest, v1.GetClusterStatusResponse](
			httpClient,
			baseURL+ClusterAPIGetClusterStatusProcedure,
			connect.WithSchema(clusterAPIMethods.ByName("GetClusterStatus")),
			connect.WithClientOptions(opts...),
		),
		listClusters: connect.NewClient[v1.ListClustersRequest, v1.ListClustersResponse](
			httpClient,
			baseURL+ClusterAPIListClustersProcedure,
			connect.WithSchema(clusterAPIMethods.ByName("ListClusters")),
			connect.WithClientOptions(opts...),
		),
		updateCluster: connect.NewClient[v1.UpdateClusterRequest, v1.UpdateClusterResponse](
			httpClient,
			baseURL+ClusterAPIUpdateClusterProcedure,
			connect.WithSchema(clusterAPIMethods.ByName("UpdateCluster")),
			connect.WithClientOptions(opts...),
		),
		deleteCluster: connect.NewClient[v1.DeleteClusterRequest, v1.DeleteClusterResponse](
			httpClient,
			baseURL+ClusterAPIDeleteClusterProcedure,
			connect.WithSchema(clusterAPIMethods.ByName("DeleteCluster")),
			connect.WithClientOptions(opts...),
		),
		createClusterToken: connect.NewClient[v1.CreateClusterTokenRequest, v1.CreateClusterTokenResponse](
			httpClient,
			baseURL+ClusterAPICreateClusterTokenProcedure,
			connect.WithSchema(clusterAPIMethods.ByName("CreateClusterToken")),
			connect.WithClientOptions(opts...),
		),
		listClusterTokens: connect.NewClient[v1.ListClusterTokensRequest, v1.ListClusterTokensResponse](
			httpClient,
			baseURL+ClusterAPIListClusterTokensProcedure,
			connect.WithSchema(clusterAPIMethods.ByName("ListClusterTokens")),
			connect.WithClientOptions(opts...),
		),
		getClusterToken: connect.NewClient[v1.GetClusterTokenRequest, v1.GetClusterTokenResponse](
			httpClient,
			baseURL+ClusterAPIGetClusterTokenProcedure,
			connect.WithSchema(clusterAPIMethods.ByName("GetClusterToken")),
			connect.WithClientOptions(opts...),
		),
		revokeClusterToken: connect.NewClient[v1.RevokeClusterTokenRequest, v1.RevokeClusterTokenResponse](
			httpClient,
			baseURL+ClusterAPIRevokeClusterTokenProcedure,
			connect.WithSchema(clusterAPIMethods.ByName("RevokeClusterToken")),
			connect.WithClientOptions(opts...),
		),
		reportClusterStatus: connect.NewClient[v1.ReportClusterStatusRequest, v1.ReportClusterStatusResponse](
			httpClient,
			baseURL+ClusterAPIReportClusterStatusProcedure,
			connect.WithSchema(clusterAPIMethods.ByName("ReportClusterStatus")),
			connect.WithClientOptions(opts...),
		),
		listWorkloads: connect.NewClient[v1.ListWorkloadsRequest, v1.ListWorkloadsResponse](
			httpClient,
			baseURL+ClusterAPIListWorkloadsProcedure,
			connect.WithSchema(clusterAPIMethods.ByName("ListWorkloads")),
			connect.WithClientOptions(opts...),
		),
		reportWorkloadStatus: connect.NewClient[v1.ReportWorkloadStatusRequest, v1.ReportWorkloadStatusResponse](
			httpClient,
			baseURL+ClusterAPIReportWorkloadStatusProcedure,
			connect.WithSchema(clusterAPIMethods.ByName("ReportWorkloadStatus")),
			connect.WithClientOptions(opts...),
		),
	}
}

// clusterAPIClient implements ClusterAPIClient.
type clusterAPIClient struct {
	createCluster        *connect.Client[v1.CreateClusterRequest, v1.CreateClusterResponse]
	getCluster           *connect.Client[v1.GetClusterRequest, v1.GetClusterResponse]
	getClusterStatus     *connect.Client[v1.GetClusterStatusRequest, v1.GetClusterStatusResponse]
	listClusters         *connect.Client[v1.ListClustersRequest, v1.ListClustersResponse]
	updateCluster        *connect.Client[v1.UpdateClusterRequest, v1.UpdateClusterResponse]
	deleteCluster        *connect.Client[v1.DeleteClusterRequest, v1.DeleteClusterResponse]
	createClusterToken   *connect.Client[v1.CreateClusterTokenRequest, v1.CreateClusterTokenResponse]
	listClusterTokens    *connect.Client[v1.ListClusterTokensRequest, v1.ListClusterTokensResponse]
	getClusterToken      *connect.Client[v1.GetClusterTokenRequest, v1.GetClusterTokenResponse]
	revokeClusterToken   *connect.Client[v1.RevokeClusterTokenRequest, v1.RevokeClusterTokenResponse]
	reportClusterStatus  *connect.Client[v1.ReportClusterStatusRequest, v1.ReportClusterStatusResponse]
	listWorkloads        *connect.Client[v1.ListWorkloadsRequest, v1.ListWorkloadsResponse]
	reportWorkloadStatus *connect.Client[v1.ReportWorkloadStatusRequest, v1.ReportWorkloadStatusResponse]
}

// CreateCluster calls admiral.api.cluster.v1.ClusterAPI.CreateCluster.
func (c *clusterAPIClient) CreateCluster(ctx context.Context, req *connect.Request[v1.CreateClusterRequest]) (*connect.Response[v1.CreateClusterResponse], error) {
	return c.createCluster.CallUnary(ctx, req)
}

// GetCluster calls admiral.api.cluster.v1.ClusterAPI.GetCluster.
func (c *clusterAPIClient) GetCluster(ctx context.Context, req *connect.Request[v1.GetClusterRequest]) (*connect.Response[v1.GetClusterResponse], error) {
	return c.getCluster.CallUnary(ctx, req)
}

// GetClusterStatus calls admiral.api.cluster.v1.ClusterAPI.GetClusterStatus.
func (c *clusterAPIClient) GetClusterStatus(ctx context.Context, req *connect.Request[v1.GetClusterStatusRequest]) (*connect.Response[v1.GetClusterStatusResponse], error) {
	return c.getClusterStatus.CallUnary(ctx, req)
}

// ListClusters calls admiral.api.cluster.v1.ClusterAPI.ListClusters.
func (c *clusterAPIClient) ListClusters(ctx context.Context, req *connect.Request[v1.ListClustersRequest]) (*connect.Response[v1.ListClustersResponse], error) {
	return c.listClusters.CallUnary(ctx, req)
}

// UpdateCluster calls admiral.api.cluster.v1.ClusterAPI.UpdateCluster.
func (c *clusterAPIClient) UpdateCluster(ctx context.Context, req *connect.Request[v1.UpdateClusterRequest]) (*connect.Response[v1.UpdateClusterResponse], error) {
	return c.updateCluster.CallUnary(ctx, req)
}

// DeleteCluster calls admiral.api.cluster.v1.ClusterAPI.DeleteCluster.
func (c *clusterAPIClient) DeleteCluster(ctx context.Context, req *connect.Request[v1.DeleteClusterRequest]) (*connect.Response[v1.DeleteClusterResponse], error) {
	return c.deleteCluster.CallUnary(ctx, req)
}

// CreateClusterToken calls admiral.api.cluster.v1.ClusterAPI.CreateClusterToken.
func (c *clusterAPIClient) CreateClusterToken(ctx context.Context, req *connect.Request[v1.CreateClusterTokenRequest]) (*connect.Response[v1.CreateClusterTokenResponse], error) {
	return c.createClusterToken.CallUnary(ctx, req)
}

// ListClusterTokens calls admiral.api.cluster.v1.ClusterAPI.ListClusterTokens.
func (c *clusterAPIClient) ListClusterTokens(ctx context.Context, req *connect.Request[v1.ListClusterTokensRequest]) (*connect.Response[v1.ListClusterTokensResponse], error) {
	return c.listClusterTokens.CallUnary(ctx, req)
}

// GetClusterToken calls admiral.api.cluster.v1.ClusterAPI.GetClusterToken.
func (c *clusterAPIClient) GetClusterToken(ctx context.Context, req *connect.Request[v1.GetClusterTokenRequest]) (*connect.Response[v1.GetClusterTokenResponse], error) {
	return c.getClusterToken.CallUnary(ctx, req)
}

// RevokeClusterToken calls admiral.api.cluster.v1.ClusterAPI.RevokeClusterToken.
func (c *clusterAPIClient) RevokeClusterToken(ctx context.Context, req *connect.Request[v1.RevokeClusterTokenRequest]) (*connect.Response[v1.RevokeClusterTokenResponse], error) {
	return c.revokeClusterToken.CallUnary(ctx, req)
}

// ReportClusterStatus calls admiral.api.cluster.v1.ClusterAPI.ReportClusterStatus.
func (c *clusterAPIClient) ReportClusterStatus(ctx context.Context, req *connect.Request[v1.ReportClusterStatusRequest]) (*connect.Response[v1.ReportClusterStatusResponse], error) {
	return c.reportClusterStatus.CallUnary(ctx, req)
}

// ListWorkloads calls admiral.api.cluster.v1.ClusterAPI.ListWorkloads.
func (c *clusterAPIClient) ListWorkloads(ctx context.Context, req *connect.Request[v1.ListWorkloadsRequest]) (*connect.Response[v1.ListWorkloadsResponse], error) {
	return c.listWorkloads.CallUnary(ctx, req)
}

// ReportWorkloadStatus calls admiral.api.cluster.v1.ClusterAPI.ReportWorkloadStatus.
func (c *clusterAPIClient) ReportWorkloadStatus(ctx context.Context, req *connect.Request[v1.ReportWorkloadStatusRequest]) (*connect.Response[v1.ReportWorkloadStatusResponse], error) {
	return c.reportWorkloadStatus.CallUnary(ctx, req)
}

// ClusterAPIHandler is an implementation of the admiral.api.cluster.v1.ClusterAPI service.
type ClusterAPIHandler interface {
	// CreateCluster creates a new cluster record within the caller's tenant and
	// generates an initial Agent Token (AGT) for the K8s agent. The cluster
	// starts in PENDING status until an agent registers against it.
	//
	// The response includes a `plain_text_token` — the raw AGT secret shown
	// exactly once. Deploy this token to the K8s agent (e.g., via Helm values
	// or a Kubernetes Secret). The agent uses it to authenticate with
	// AgentAPI.RegisterAgent on first boot.
	//
	// Scope: `clusters:write`
	CreateCluster(context.Context, *connect.Request[v1.CreateClusterRequest]) (*connect.Response[v1.CreateClusterResponse], error)
	// GetCluster retrieves a cluster by ID.
	//
	// Returns the Cluster record with its server-derived health_status. For
	// detailed telemetry (node counts, resource usage, workload summary), use
	// GetClusterStatus instead.
	//
	// Scope: `clusters:read`
	GetCluster(context.Context, *connect.Request[v1.GetClusterRequest]) (*connect.Response[v1.GetClusterResponse], error)
	// GetClusterStatus retrieves the current telemetry snapshot for a cluster.
	// Returns the latest metrics pushed by the agent, along with server-derived
	// health status and workload summary counts.
	//
	// Returns NOT_FOUND if the cluster does not exist. If the cluster exists but
	// no agent has reported telemetry yet, the response will have health_status
	// PENDING and no status message.
	//
	// Scope: `clusters:read`
	GetClusterStatus(context.Context, *connect.Request[v1.GetClusterStatusRequest]) (*connect.Response[v1.GetClusterStatusResponse], error)
	// ListClusters returns a paginated list of clusters within the caller's tenant.
	//
	// Scope: `clusters:read`
	ListClusters(context.Context, *connect.Request[v1.ListClustersRequest]) (*connect.Response[v1.ListClustersResponse], error)
	// UpdateCluster updates a cluster's mutable fields (display name, labels).
	// Use the `update_mask` to specify which fields to update.
	//
	// Scope: `clusters:write`
	UpdateCluster(context.Context, *connect.Request[v1.UpdateClusterRequest]) (*connect.Response[v1.UpdateClusterResponse], error)
	// DeleteCluster permanently deletes a cluster record and revokes all
	// associated agent tokens. This action cannot be undone.
	//
	// Scope: `clusters:write`
	DeleteCluster(context.Context, *connect.Request[v1.DeleteClusterRequest]) (*connect.Response[v1.DeleteClusterResponse], error)
	// CreateClusterToken creates a new Agent Token (AGT) bound to the specified
	// cluster. Scopes are auto-assigned and cannot be overridden. The response
	// includes the raw token secret, which is shown exactly once.
	//
	// Use this to create additional AGTs for an existing cluster (e.g., for
	// zero-downtime token rotation). The initial AGT is created automatically
	// by CreateCluster.
	//
	// Scope: `clusters:write`
	CreateClusterToken(context.Context, *connect.Request[v1.CreateClusterTokenRequest]) (*connect.Response[v1.CreateClusterTokenResponse], error)
	// ListClusterTokens returns a paginated list of AGTs bound to the specified
	// cluster. Token secrets are never included.
	//
	// Scope: `clusters:read`
	ListClusterTokens(context.Context, *connect.Request[v1.ListClusterTokensRequest]) (*connect.Response[v1.ListClusterTokensResponse], error)
	// GetClusterToken retrieves a single AGT by ID.
	// Returns metadata only — the token secret is never included.
	//
	// Scope: `clusters:read`
	GetClusterToken(context.Context, *connect.Request[v1.GetClusterTokenRequest]) (*connect.Response[v1.GetClusterTokenResponse], error)
	// RevokeClusterToken permanently revokes an AGT bound to this cluster.
	// The agent will receive a 401 on its next request. If this is the only
	// active AGT for the cluster, the agent will become disconnected.
	//
	// Scope: `clusters:write`
	RevokeClusterToken(context.Context, *connect.Request[v1.RevokeClusterTokenRequest]) (*connect.Response[v1.RevokeClusterTokenResponse], error)
	// ReportClusterStatus receives a combined telemetry snapshot from a K8s agent.
	// The payload includes cluster-level metrics, per-workload status, and
	// Kubernetes events. Admiral splits this into three storage tiers on receipt.
	//
	// This endpoint is agent-facing and restricted to agent tokens.
	//
	// Scope: `clusters:status` | Token types: `agt`
	ReportClusterStatus(context.Context, *connect.Request[v1.ReportClusterStatusRequest]) (*connect.Response[v1.ReportClusterStatusResponse], error)
	// ListWorkloads returns a paginated list of workloads running in a specific cluster.
	//
	// Scope: `clusters:read`
	ListWorkloads(context.Context, *connect.Request[v1.ListWorkloadsRequest]) (*connect.Response[v1.ListWorkloadsResponse], error)
	// ReportWorkloadStatus receives workload-only telemetry from a K8s agent.
	// Used for incremental workload updates between full cluster status pushes.
	//
	// This endpoint is agent-facing and restricted to agent tokens.
	//
	// Scope: `clusters:status` | Token types: `agt`
	ReportWorkloadStatus(context.Context, *connect.Request[v1.ReportWorkloadStatusRequest]) (*connect.Response[v1.ReportWorkloadStatusResponse], error)
}

// NewClusterAPIHandler builds an HTTP handler from the service implementation. It returns the path
// on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewClusterAPIHandler(svc ClusterAPIHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	clusterAPIMethods := v1.File_cluster_v1_cluster_proto.Services().ByName("ClusterAPI").Methods()
	clusterAPICreateClusterHandler := connect.NewUnaryHandler(
		ClusterAPICreateClusterProcedure,
		svc.CreateCluster,
		connect.WithSchema(clusterAPIMethods.ByName("CreateCluster")),
		connect.WithHandlerOptions(opts...),
	)
	clusterAPIGetClusterHandler := connect.NewUnaryHandler(
		ClusterAPIGetClusterProcedure,
		svc.GetCluster,
		connect.WithSchema(clusterAPIMethods.ByName("GetCluster")),
		connect.WithHandlerOptions(opts...),
	)
	clusterAPIGetClusterStatusHandler := connect.NewUnaryHandler(
		ClusterAPIGetClusterStatusProcedure,
		svc.GetClusterStatus,
		connect.WithSchema(clusterAPIMethods.ByName("GetClusterStatus")),
		connect.WithHandlerOptions(opts...),
	)
	clusterAPIListClustersHandler := connect.NewUnaryHandler(
		ClusterAPIListClustersProcedure,
		svc.ListClusters,
		connect.WithSchema(clusterAPIMethods.ByName("ListClusters")),
		connect.WithHandlerOptions(opts...),
	)
	clusterAPIUpdateClusterHandler := connect.NewUnaryHandler(
		ClusterAPIUpdateClusterProcedure,
		svc.UpdateCluster,
		connect.WithSchema(clusterAPIMethods.ByName("UpdateCluster")),
		connect.WithHandlerOptions(opts...),
	)
	clusterAPIDeleteClusterHandler := connect.NewUnaryHandler(
		ClusterAPIDeleteClusterProcedure,
		svc.DeleteCluster,
		connect.WithSchema(clusterAPIMethods.ByName("DeleteCluster")),
		connect.WithHandlerOptions(opts...),
	)
	clusterAPICreateClusterTokenHandler := connect.NewUnaryHandler(
		ClusterAPICreateClusterTokenProcedure,
		svc.CreateClusterToken,
		connect.WithSchema(clusterAPIMethods.ByName("CreateClusterToken")),
		connect.WithHandlerOptions(opts...),
	)
	clusterAPIListClusterTokensHandler := connect.NewUnaryHandler(
		ClusterAPIListClusterTokensProcedure,
		svc.ListClusterTokens,
		connect.WithSchema(clusterAPIMethods.ByName("ListClusterTokens")),
		connect.WithHandlerOptions(opts...),
	)
	clusterAPIGetClusterTokenHandler := connect.NewUnaryHandler(
		ClusterAPIGetClusterTokenProcedure,
		svc.GetClusterToken,
		connect.WithSchema(clusterAPIMethods.ByName("GetClusterToken")),
		connect.WithHandlerOptions(opts...),
	)
	clusterAPIRevokeClusterTokenHandler := connect.NewUnaryHandler(
		ClusterAPIRevokeClusterTokenProcedure,
		svc.RevokeClusterToken,
		connect.WithSchema(clusterAPIMethods.ByName("RevokeClusterToken")),
		connect.WithHandlerOptions(opts...),
	)
	clusterAPIReportClusterStatusHandler := connect.NewUnaryHandler(
		ClusterAPIReportClusterStatusProcedure,
		svc.ReportClusterStatus,
		connect.WithSchema(clusterAPIMethods.ByName("ReportClusterStatus")),
		connect.WithHandlerOptions(opts...),
	)
	clusterAPIListWorkloadsHandler := connect.NewUnaryHandler(
		ClusterAPIListWorkloadsProcedure,
		svc.ListWorkloads,
		connect.WithSchema(clusterAPIMethods.ByName("ListWorkloads")),
		connect.WithHandlerOptions(opts...),
	)
	clusterAPIReportWorkloadStatusHandler := connect.NewUnaryHandler(
		ClusterAPIReportWorkloadStatusProcedure,
		svc.ReportWorkloadStatus,
		connect.WithSchema(clusterAPIMethods.ByName("ReportWorkloadStatus")),
		connect.WithHandlerOptions(opts...),
	)
	return "/admiral.api.cluster.v1.ClusterAPI/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case ClusterAPICreateClusterProcedure:
			clusterAPICreateClusterHandler.ServeHTTP(w, r)
		case ClusterAPIGetClusterProcedure:
			clusterAPIGetClusterHandler.ServeHTTP(w, r)
		case ClusterAPIGetClusterStatusProcedure:
			clusterAPIGetClusterStatusHandler.ServeHTTP(w, r)
		case ClusterAPIListClustersProcedure:
			clusterAPIListClustersHandler.ServeHTTP(w, r)
		case ClusterAPIUpdateClusterProcedure:
			clusterAPIUpdateClusterHandler.ServeHTTP(w, r)
		case ClusterAPIDeleteClusterProcedure:
			clusterAPIDeleteClusterHandler.ServeHTTP(w, r)
		case ClusterAPICreateClusterTokenProcedure:
			clusterAPICreateClusterTokenHandler.ServeHTTP(w, r)
		case ClusterAPIListClusterTokensProcedure:
			clusterAPIListClusterTokensHandler.ServeHTTP(w, r)
		case ClusterAPIGetClusterTokenProcedure:
			clusterAPIGetClusterTokenHandler.ServeHTTP(w, r)
		case ClusterAPIRevokeClusterTokenProcedure:
			clusterAPIRevokeClusterTokenHandler.ServeHTTP(w, r)
		case ClusterAPIReportClusterStatusProcedure:
			clusterAPIReportClusterStatusHandler.ServeHTTP(w, r)
		case ClusterAPIListWorkloadsProcedure:
			clusterAPIListWorkloadsHandler.ServeHTTP(w, r)
		case ClusterAPIReportWorkloadStatusProcedure:
			clusterAPIReportWorkloadStatusHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedClusterAPIHandler returns CodeUnimplemented from all methods.
type UnimplementedClusterAPIHandler struct{}

func (UnimplementedClusterAPIHandler) CreateCluster(context.Context, *connect.Request[v1.CreateClusterRequest]) (*connect.Response[v1.CreateClusterResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("admiral.api.cluster.v1.ClusterAPI.CreateCluster is not implemented"))
}

func (UnimplementedClusterAPIHandler) GetCluster(context.Context, *connect.Request[v1.GetClusterRequest]) (*connect.Response[v1.GetClusterResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("admiral.api.cluster.v1.ClusterAPI.GetCluster is not implemented"))
}

func (UnimplementedClusterAPIHandler) GetClusterStatus(context.Context, *connect.Request[v1.GetClusterStatusRequest]) (*connect.Response[v1.GetClusterStatusResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("admiral.api.cluster.v1.ClusterAPI.GetClusterStatus is not implemented"))
}

func (UnimplementedClusterAPIHandler) ListClusters(context.Context, *connect.Request[v1.ListClustersRequest]) (*connect.Response[v1.ListClustersResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("admiral.api.cluster.v1.ClusterAPI.ListClusters is not implemented"))
}

func (UnimplementedClusterAPIHandler) UpdateCluster(context.Context, *connect.Request[v1.UpdateClusterRequest]) (*connect.Response[v1.UpdateClusterResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("admiral.api.cluster.v1.ClusterAPI.UpdateCluster is not implemented"))
}

func (UnimplementedClusterAPIHandler) DeleteCluster(context.Context, *connect.Request[v1.DeleteClusterRequest]) (*connect.Response[v1.DeleteClusterResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("admiral.api.cluster.v1.ClusterAPI.DeleteCluster is not implemented"))
}

func (UnimplementedClusterAPIHandler) CreateClusterToken(context.Context, *connect.Request[v1.CreateClusterTokenRequest]) (*connect.Response[v1.CreateClusterTokenResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("admiral.api.cluster.v1.ClusterAPI.CreateClusterToken is not implemented"))
}

func (UnimplementedClusterAPIHandler) ListClusterTokens(context.Context, *connect.Request[v1.ListClusterTokensRequest]) (*connect.Response[v1.ListClusterTokensResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("admiral.api.cluster.v1.ClusterAPI.ListClusterTokens is not implemented"))
}

func (UnimplementedClusterAPIHandler) GetClusterToken(context.Context, *connect.Request[v1.GetClusterTokenRequest]) (*connect.Response[v1.GetClusterTokenResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("admiral.api.cluster.v1.ClusterAPI.GetClusterToken is not implemented"))
}

func (UnimplementedClusterAPIHandler) RevokeClusterToken(context.Context, *connect.Request[v1.RevokeClusterTokenRequest]) (*connect.Response[v1.RevokeClusterTokenResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("admiral.api.cluster.v1.ClusterAPI.RevokeClusterToken is not implemented"))
}

func (UnimplementedClusterAPIHandler) ReportClusterStatus(context.Context, *connect.Request[v1.ReportClusterStatusRequest]) (*connect.Response[v1.ReportClusterStatusResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("admiral.api.cluster.v1.ClusterAPI.ReportClusterStatus is not implemented"))
}

func (UnimplementedClusterAPIHandler) ListWorkloads(context.Context, *connect.Request[v1.ListWorkloadsRequest]) (*connect.Response[v1.ListWorkloadsResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("admiral.api.cluster.v1.ClusterAPI.ListWorkloads is not implemented"))
}

func (UnimplementedClusterAPIHandler) ReportWorkloadStatus(context.Context, *connect.Request[v1.ReportWorkloadStatusRequest]) (*connect.Response[v1.ReportWorkloadStatusResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("admiral.api.cluster.v1.ClusterAPI.ReportWorkloadStatus is not implemented"))
}
