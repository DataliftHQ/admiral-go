// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.1
// - protoc             (unknown)
// source: cluster/v1/cluster.proto

package clusterv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	ClusterAPI_CreateCluster_FullMethodName        = "/admiral.api.cluster.v1.ClusterAPI/CreateCluster"
	ClusterAPI_GetCluster_FullMethodName           = "/admiral.api.cluster.v1.ClusterAPI/GetCluster"
	ClusterAPI_GetClusterStatus_FullMethodName     = "/admiral.api.cluster.v1.ClusterAPI/GetClusterStatus"
	ClusterAPI_ListClusters_FullMethodName         = "/admiral.api.cluster.v1.ClusterAPI/ListClusters"
	ClusterAPI_UpdateCluster_FullMethodName        = "/admiral.api.cluster.v1.ClusterAPI/UpdateCluster"
	ClusterAPI_DeleteCluster_FullMethodName        = "/admiral.api.cluster.v1.ClusterAPI/DeleteCluster"
	ClusterAPI_CreateClusterToken_FullMethodName   = "/admiral.api.cluster.v1.ClusterAPI/CreateClusterToken"
	ClusterAPI_ListClusterTokens_FullMethodName    = "/admiral.api.cluster.v1.ClusterAPI/ListClusterTokens"
	ClusterAPI_GetClusterToken_FullMethodName      = "/admiral.api.cluster.v1.ClusterAPI/GetClusterToken"
	ClusterAPI_RevokeClusterToken_FullMethodName   = "/admiral.api.cluster.v1.ClusterAPI/RevokeClusterToken"
	ClusterAPI_ReportClusterStatus_FullMethodName  = "/admiral.api.cluster.v1.ClusterAPI/ReportClusterStatus"
	ClusterAPI_ListWorkloads_FullMethodName        = "/admiral.api.cluster.v1.ClusterAPI/ListWorkloads"
	ClusterAPI_ReportWorkloadStatus_FullMethodName = "/admiral.api.cluster.v1.ClusterAPI/ReportWorkloadStatus"
)

// ClusterAPIClient is the client API for ClusterAPI service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ClusterAPI manages Kubernetes clusters and their workload telemetry.
//
// Administrators create clusters via CreateCluster, which returns an Agent
// Token (AGT) for deploying the K8s agent. Once the agent boots and calls
// AgentAPI.RegisterAgent, the cluster transitions from PENDING to HEALTHY
// and begins receiving telemetry.
//
// The telemetry model has three tiers: current snapshot (upserted per push),
// time-series metrics (rolling 48-hour window), and events (rolling 7-day window).
type ClusterAPIClient interface {
	// CreateCluster creates a new cluster record within the caller's tenant and
	// generates an initial Agent Token (AGT) for the K8s agent. The cluster
	// starts in PENDING status until an agent registers against it.
	//
	// The response includes a `plain_text_token` — the raw AGT secret shown
	// exactly once. Deploy this token to the K8s agent (e.g., via Helm values
	// or a Kubernetes Secret). The agent uses it to authenticate with
	// AgentAPI.RegisterAgent on first boot.
	//
	// Scope: `clusters:write`
	CreateCluster(ctx context.Context, in *CreateClusterRequest, opts ...grpc.CallOption) (*CreateClusterResponse, error)
	// GetCluster retrieves a cluster by ID.
	//
	// Returns the Cluster record with its server-derived health_status. For
	// detailed telemetry (node counts, resource usage, workload summary), use
	// GetClusterStatus instead.
	//
	// Scope: `clusters:read`
	GetCluster(ctx context.Context, in *GetClusterRequest, opts ...grpc.CallOption) (*GetClusterResponse, error)
	// GetClusterStatus retrieves the current telemetry snapshot for a cluster.
	// Returns the latest metrics pushed by the agent, along with server-derived
	// health status and workload summary counts.
	//
	// Returns NOT_FOUND if the cluster does not exist. If the cluster exists but
	// no agent has reported telemetry yet, the response will have health_status
	// PENDING and no status message.
	//
	// Scope: `clusters:read`
	GetClusterStatus(ctx context.Context, in *GetClusterStatusRequest, opts ...grpc.CallOption) (*GetClusterStatusResponse, error)
	// ListClusters returns a paginated list of clusters within the caller's tenant.
	//
	// Scope: `clusters:read`
	ListClusters(ctx context.Context, in *ListClustersRequest, opts ...grpc.CallOption) (*ListClustersResponse, error)
	// UpdateCluster updates a cluster's mutable fields (display name, labels).
	// Use the `update_mask` to specify which fields to update.
	//
	// Scope: `clusters:write`
	UpdateCluster(ctx context.Context, in *UpdateClusterRequest, opts ...grpc.CallOption) (*UpdateClusterResponse, error)
	// DeleteCluster permanently deletes a cluster record and revokes all
	// associated agent tokens. This action cannot be undone.
	//
	// Scope: `clusters:write`
	DeleteCluster(ctx context.Context, in *DeleteClusterRequest, opts ...grpc.CallOption) (*DeleteClusterResponse, error)
	// CreateClusterToken creates a new Agent Token (AGT) bound to the specified
	// cluster. Scopes are auto-assigned and cannot be overridden. The response
	// includes the raw token secret, which is shown exactly once.
	//
	// Use this to create additional AGTs for an existing cluster (e.g., for
	// zero-downtime token rotation). The initial AGT is created automatically
	// by CreateCluster.
	//
	// Scope: `clusters:write`
	CreateClusterToken(ctx context.Context, in *CreateClusterTokenRequest, opts ...grpc.CallOption) (*CreateClusterTokenResponse, error)
	// ListClusterTokens returns a paginated list of AGTs bound to the specified
	// cluster. Token secrets are never included.
	//
	// Scope: `clusters:read`
	ListClusterTokens(ctx context.Context, in *ListClusterTokensRequest, opts ...grpc.CallOption) (*ListClusterTokensResponse, error)
	// GetClusterToken retrieves a single AGT by ID.
	// Returns metadata only — the token secret is never included.
	//
	// Scope: `clusters:read`
	GetClusterToken(ctx context.Context, in *GetClusterTokenRequest, opts ...grpc.CallOption) (*GetClusterTokenResponse, error)
	// RevokeClusterToken permanently revokes an AGT bound to this cluster.
	// The agent will receive a 401 on its next request. If this is the only
	// active AGT for the cluster, the agent will become disconnected.
	//
	// Scope: `clusters:write`
	RevokeClusterToken(ctx context.Context, in *RevokeClusterTokenRequest, opts ...grpc.CallOption) (*RevokeClusterTokenResponse, error)
	// ReportClusterStatus receives a combined telemetry snapshot from a K8s agent.
	// The payload includes cluster-level metrics, per-workload status, and
	// Kubernetes events. Admiral splits this into three storage tiers on receipt.
	//
	// This endpoint is agent-facing and restricted to agent tokens.
	//
	// Scope: `clusters:status` | Token types: `agt`
	ReportClusterStatus(ctx context.Context, in *ReportClusterStatusRequest, opts ...grpc.CallOption) (*ReportClusterStatusResponse, error)
	// ListWorkloads returns a paginated list of workloads running in a specific cluster.
	//
	// Scope: `clusters:read`
	ListWorkloads(ctx context.Context, in *ListWorkloadsRequest, opts ...grpc.CallOption) (*ListWorkloadsResponse, error)
	// ReportWorkloadStatus receives workload-only telemetry from a K8s agent.
	// Used for incremental workload updates between full cluster status pushes.
	//
	// This endpoint is agent-facing and restricted to agent tokens.
	//
	// Scope: `clusters:status` | Token types: `agt`
	ReportWorkloadStatus(ctx context.Context, in *ReportWorkloadStatusRequest, opts ...grpc.CallOption) (*ReportWorkloadStatusResponse, error)
}

type clusterAPIClient struct {
	cc grpc.ClientConnInterface
}

func NewClusterAPIClient(cc grpc.ClientConnInterface) ClusterAPIClient {
	return &clusterAPIClient{cc}
}

func (c *clusterAPIClient) CreateCluster(ctx context.Context, in *CreateClusterRequest, opts ...grpc.CallOption) (*CreateClusterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateClusterResponse)
	err := c.cc.Invoke(ctx, ClusterAPI_CreateCluster_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterAPIClient) GetCluster(ctx context.Context, in *GetClusterRequest, opts ...grpc.CallOption) (*GetClusterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetClusterResponse)
	err := c.cc.Invoke(ctx, ClusterAPI_GetCluster_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterAPIClient) GetClusterStatus(ctx context.Context, in *GetClusterStatusRequest, opts ...grpc.CallOption) (*GetClusterStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetClusterStatusResponse)
	err := c.cc.Invoke(ctx, ClusterAPI_GetClusterStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterAPIClient) ListClusters(ctx context.Context, in *ListClustersRequest, opts ...grpc.CallOption) (*ListClustersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListClustersResponse)
	err := c.cc.Invoke(ctx, ClusterAPI_ListClusters_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterAPIClient) UpdateCluster(ctx context.Context, in *UpdateClusterRequest, opts ...grpc.CallOption) (*UpdateClusterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateClusterResponse)
	err := c.cc.Invoke(ctx, ClusterAPI_UpdateCluster_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterAPIClient) DeleteCluster(ctx context.Context, in *DeleteClusterRequest, opts ...grpc.CallOption) (*DeleteClusterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteClusterResponse)
	err := c.cc.Invoke(ctx, ClusterAPI_DeleteCluster_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterAPIClient) CreateClusterToken(ctx context.Context, in *CreateClusterTokenRequest, opts ...grpc.CallOption) (*CreateClusterTokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateClusterTokenResponse)
	err := c.cc.Invoke(ctx, ClusterAPI_CreateClusterToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterAPIClient) ListClusterTokens(ctx context.Context, in *ListClusterTokensRequest, opts ...grpc.CallOption) (*ListClusterTokensResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListClusterTokensResponse)
	err := c.cc.Invoke(ctx, ClusterAPI_ListClusterTokens_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterAPIClient) GetClusterToken(ctx context.Context, in *GetClusterTokenRequest, opts ...grpc.CallOption) (*GetClusterTokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetClusterTokenResponse)
	err := c.cc.Invoke(ctx, ClusterAPI_GetClusterToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterAPIClient) RevokeClusterToken(ctx context.Context, in *RevokeClusterTokenRequest, opts ...grpc.CallOption) (*RevokeClusterTokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RevokeClusterTokenResponse)
	err := c.cc.Invoke(ctx, ClusterAPI_RevokeClusterToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterAPIClient) ReportClusterStatus(ctx context.Context, in *ReportClusterStatusRequest, opts ...grpc.CallOption) (*ReportClusterStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReportClusterStatusResponse)
	err := c.cc.Invoke(ctx, ClusterAPI_ReportClusterStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterAPIClient) ListWorkloads(ctx context.Context, in *ListWorkloadsRequest, opts ...grpc.CallOption) (*ListWorkloadsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListWorkloadsResponse)
	err := c.cc.Invoke(ctx, ClusterAPI_ListWorkloads_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterAPIClient) ReportWorkloadStatus(ctx context.Context, in *ReportWorkloadStatusRequest, opts ...grpc.CallOption) (*ReportWorkloadStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReportWorkloadStatusResponse)
	err := c.cc.Invoke(ctx, ClusterAPI_ReportWorkloadStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ClusterAPIServer is the server API for ClusterAPI service.
// All implementations should embed UnimplementedClusterAPIServer
// for forward compatibility.
//
// ClusterAPI manages Kubernetes clusters and their workload telemetry.
//
// Administrators create clusters via CreateCluster, which returns an Agent
// Token (AGT) for deploying the K8s agent. Once the agent boots and calls
// AgentAPI.RegisterAgent, the cluster transitions from PENDING to HEALTHY
// and begins receiving telemetry.
//
// The telemetry model has three tiers: current snapshot (upserted per push),
// time-series metrics (rolling 48-hour window), and events (rolling 7-day window).
type ClusterAPIServer interface {
	// CreateCluster creates a new cluster record within the caller's tenant and
	// generates an initial Agent Token (AGT) for the K8s agent. The cluster
	// starts in PENDING status until an agent registers against it.
	//
	// The response includes a `plain_text_token` — the raw AGT secret shown
	// exactly once. Deploy this token to the K8s agent (e.g., via Helm values
	// or a Kubernetes Secret). The agent uses it to authenticate with
	// AgentAPI.RegisterAgent on first boot.
	//
	// Scope: `clusters:write`
	CreateCluster(context.Context, *CreateClusterRequest) (*CreateClusterResponse, error)
	// GetCluster retrieves a cluster by ID.
	//
	// Returns the Cluster record with its server-derived health_status. For
	// detailed telemetry (node counts, resource usage, workload summary), use
	// GetClusterStatus instead.
	//
	// Scope: `clusters:read`
	GetCluster(context.Context, *GetClusterRequest) (*GetClusterResponse, error)
	// GetClusterStatus retrieves the current telemetry snapshot for a cluster.
	// Returns the latest metrics pushed by the agent, along with server-derived
	// health status and workload summary counts.
	//
	// Returns NOT_FOUND if the cluster does not exist. If the cluster exists but
	// no agent has reported telemetry yet, the response will have health_status
	// PENDING and no status message.
	//
	// Scope: `clusters:read`
	GetClusterStatus(context.Context, *GetClusterStatusRequest) (*GetClusterStatusResponse, error)
	// ListClusters returns a paginated list of clusters within the caller's tenant.
	//
	// Scope: `clusters:read`
	ListClusters(context.Context, *ListClustersRequest) (*ListClustersResponse, error)
	// UpdateCluster updates a cluster's mutable fields (display name, labels).
	// Use the `update_mask` to specify which fields to update.
	//
	// Scope: `clusters:write`
	UpdateCluster(context.Context, *UpdateClusterRequest) (*UpdateClusterResponse, error)
	// DeleteCluster permanently deletes a cluster record and revokes all
	// associated agent tokens. This action cannot be undone.
	//
	// Scope: `clusters:write`
	DeleteCluster(context.Context, *DeleteClusterRequest) (*DeleteClusterResponse, error)
	// CreateClusterToken creates a new Agent Token (AGT) bound to the specified
	// cluster. Scopes are auto-assigned and cannot be overridden. The response
	// includes the raw token secret, which is shown exactly once.
	//
	// Use this to create additional AGTs for an existing cluster (e.g., for
	// zero-downtime token rotation). The initial AGT is created automatically
	// by CreateCluster.
	//
	// Scope: `clusters:write`
	CreateClusterToken(context.Context, *CreateClusterTokenRequest) (*CreateClusterTokenResponse, error)
	// ListClusterTokens returns a paginated list of AGTs bound to the specified
	// cluster. Token secrets are never included.
	//
	// Scope: `clusters:read`
	ListClusterTokens(context.Context, *ListClusterTokensRequest) (*ListClusterTokensResponse, error)
	// GetClusterToken retrieves a single AGT by ID.
	// Returns metadata only — the token secret is never included.
	//
	// Scope: `clusters:read`
	GetClusterToken(context.Context, *GetClusterTokenRequest) (*GetClusterTokenResponse, error)
	// RevokeClusterToken permanently revokes an AGT bound to this cluster.
	// The agent will receive a 401 on its next request. If this is the only
	// active AGT for the cluster, the agent will become disconnected.
	//
	// Scope: `clusters:write`
	RevokeClusterToken(context.Context, *RevokeClusterTokenRequest) (*RevokeClusterTokenResponse, error)
	// ReportClusterStatus receives a combined telemetry snapshot from a K8s agent.
	// The payload includes cluster-level metrics, per-workload status, and
	// Kubernetes events. Admiral splits this into three storage tiers on receipt.
	//
	// This endpoint is agent-facing and restricted to agent tokens.
	//
	// Scope: `clusters:status` | Token types: `agt`
	ReportClusterStatus(context.Context, *ReportClusterStatusRequest) (*ReportClusterStatusResponse, error)
	// ListWorkloads returns a paginated list of workloads running in a specific cluster.
	//
	// Scope: `clusters:read`
	ListWorkloads(context.Context, *ListWorkloadsRequest) (*ListWorkloadsResponse, error)
	// ReportWorkloadStatus receives workload-only telemetry from a K8s agent.
	// Used for incremental workload updates between full cluster status pushes.
	//
	// This endpoint is agent-facing and restricted to agent tokens.
	//
	// Scope: `clusters:status` | Token types: `agt`
	ReportWorkloadStatus(context.Context, *ReportWorkloadStatusRequest) (*ReportWorkloadStatusResponse, error)
}

// UnimplementedClusterAPIServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedClusterAPIServer struct{}

func (UnimplementedClusterAPIServer) CreateCluster(context.Context, *CreateClusterRequest) (*CreateClusterResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateCluster not implemented")
}
func (UnimplementedClusterAPIServer) GetCluster(context.Context, *GetClusterRequest) (*GetClusterResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetCluster not implemented")
}
func (UnimplementedClusterAPIServer) GetClusterStatus(context.Context, *GetClusterStatusRequest) (*GetClusterStatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetClusterStatus not implemented")
}
func (UnimplementedClusterAPIServer) ListClusters(context.Context, *ListClustersRequest) (*ListClustersResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListClusters not implemented")
}
func (UnimplementedClusterAPIServer) UpdateCluster(context.Context, *UpdateClusterRequest) (*UpdateClusterResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateCluster not implemented")
}
func (UnimplementedClusterAPIServer) DeleteCluster(context.Context, *DeleteClusterRequest) (*DeleteClusterResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteCluster not implemented")
}
func (UnimplementedClusterAPIServer) CreateClusterToken(context.Context, *CreateClusterTokenRequest) (*CreateClusterTokenResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateClusterToken not implemented")
}
func (UnimplementedClusterAPIServer) ListClusterTokens(context.Context, *ListClusterTokensRequest) (*ListClusterTokensResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListClusterTokens not implemented")
}
func (UnimplementedClusterAPIServer) GetClusterToken(context.Context, *GetClusterTokenRequest) (*GetClusterTokenResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetClusterToken not implemented")
}
func (UnimplementedClusterAPIServer) RevokeClusterToken(context.Context, *RevokeClusterTokenRequest) (*RevokeClusterTokenResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RevokeClusterToken not implemented")
}
func (UnimplementedClusterAPIServer) ReportClusterStatus(context.Context, *ReportClusterStatusRequest) (*ReportClusterStatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReportClusterStatus not implemented")
}
func (UnimplementedClusterAPIServer) ListWorkloads(context.Context, *ListWorkloadsRequest) (*ListWorkloadsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListWorkloads not implemented")
}
func (UnimplementedClusterAPIServer) ReportWorkloadStatus(context.Context, *ReportWorkloadStatusRequest) (*ReportWorkloadStatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReportWorkloadStatus not implemented")
}
func (UnimplementedClusterAPIServer) testEmbeddedByValue() {}

// UnsafeClusterAPIServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ClusterAPIServer will
// result in compilation errors.
type UnsafeClusterAPIServer interface {
	mustEmbedUnimplementedClusterAPIServer()
}

func RegisterClusterAPIServer(s grpc.ServiceRegistrar, srv ClusterAPIServer) {
	// If the following call panics, it indicates UnimplementedClusterAPIServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ClusterAPI_ServiceDesc, srv)
}

func _ClusterAPI_CreateCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateClusterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterAPIServer).CreateCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClusterAPI_CreateCluster_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterAPIServer).CreateCluster(ctx, req.(*CreateClusterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterAPI_GetCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClusterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterAPIServer).GetCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClusterAPI_GetCluster_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterAPIServer).GetCluster(ctx, req.(*GetClusterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterAPI_GetClusterStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClusterStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterAPIServer).GetClusterStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClusterAPI_GetClusterStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterAPIServer).GetClusterStatus(ctx, req.(*GetClusterStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterAPI_ListClusters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListClustersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterAPIServer).ListClusters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClusterAPI_ListClusters_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterAPIServer).ListClusters(ctx, req.(*ListClustersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterAPI_UpdateCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateClusterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterAPIServer).UpdateCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClusterAPI_UpdateCluster_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterAPIServer).UpdateCluster(ctx, req.(*UpdateClusterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterAPI_DeleteCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteClusterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterAPIServer).DeleteCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClusterAPI_DeleteCluster_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterAPIServer).DeleteCluster(ctx, req.(*DeleteClusterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterAPI_CreateClusterToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateClusterTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterAPIServer).CreateClusterToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClusterAPI_CreateClusterToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterAPIServer).CreateClusterToken(ctx, req.(*CreateClusterTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterAPI_ListClusterTokens_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListClusterTokensRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterAPIServer).ListClusterTokens(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClusterAPI_ListClusterTokens_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterAPIServer).ListClusterTokens(ctx, req.(*ListClusterTokensRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterAPI_GetClusterToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClusterTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterAPIServer).GetClusterToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClusterAPI_GetClusterToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterAPIServer).GetClusterToken(ctx, req.(*GetClusterTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterAPI_RevokeClusterToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RevokeClusterTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterAPIServer).RevokeClusterToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClusterAPI_RevokeClusterToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterAPIServer).RevokeClusterToken(ctx, req.(*RevokeClusterTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterAPI_ReportClusterStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportClusterStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterAPIServer).ReportClusterStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClusterAPI_ReportClusterStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterAPIServer).ReportClusterStatus(ctx, req.(*ReportClusterStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterAPI_ListWorkloads_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListWorkloadsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterAPIServer).ListWorkloads(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClusterAPI_ListWorkloads_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterAPIServer).ListWorkloads(ctx, req.(*ListWorkloadsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterAPI_ReportWorkloadStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportWorkloadStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterAPIServer).ReportWorkloadStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClusterAPI_ReportWorkloadStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterAPIServer).ReportWorkloadStatus(ctx, req.(*ReportWorkloadStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ClusterAPI_ServiceDesc is the grpc.ServiceDesc for ClusterAPI service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ClusterAPI_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "admiral.api.cluster.v1.ClusterAPI",
	HandlerType: (*ClusterAPIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateCluster",
			Handler:    _ClusterAPI_CreateCluster_Handler,
		},
		{
			MethodName: "GetCluster",
			Handler:    _ClusterAPI_GetCluster_Handler,
		},
		{
			MethodName: "GetClusterStatus",
			Handler:    _ClusterAPI_GetClusterStatus_Handler,
		},
		{
			MethodName: "ListClusters",
			Handler:    _ClusterAPI_ListClusters_Handler,
		},
		{
			MethodName: "UpdateCluster",
			Handler:    _ClusterAPI_UpdateCluster_Handler,
		},
		{
			MethodName: "DeleteCluster",
			Handler:    _ClusterAPI_DeleteCluster_Handler,
		},
		{
			MethodName: "CreateClusterToken",
			Handler:    _ClusterAPI_CreateClusterToken_Handler,
		},
		{
			MethodName: "ListClusterTokens",
			Handler:    _ClusterAPI_ListClusterTokens_Handler,
		},
		{
			MethodName: "GetClusterToken",
			Handler:    _ClusterAPI_GetClusterToken_Handler,
		},
		{
			MethodName: "RevokeClusterToken",
			Handler:    _ClusterAPI_RevokeClusterToken_Handler,
		},
		{
			MethodName: "ReportClusterStatus",
			Handler:    _ClusterAPI_ReportClusterStatus_Handler,
		},
		{
			MethodName: "ListWorkloads",
			Handler:    _ClusterAPI_ListWorkloads_Handler,
		},
		{
			MethodName: "ReportWorkloadStatus",
			Handler:    _ClusterAPI_ReportWorkloadStatus_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cluster/v1/cluster.proto",
}
