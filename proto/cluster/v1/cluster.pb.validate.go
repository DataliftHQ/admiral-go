// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: cluster/v1/cluster.proto

package clusterv1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Cluster with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Cluster) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Cluster with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ClusterMultiError, or nil if none found.
func (m *Cluster) ValidateAll() error {
	return m.validate(true)
}

func (m *Cluster) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for TenantId

	// no validation rules for DisplayName

	// no validation rules for Labels

	// no validation rules for ClusterUid

	// no validation rules for HealthStatus

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ClusterMultiError(errors)
	}

	return nil
}

// ClusterMultiError is an error wrapping multiple validation errors returned
// by Cluster.ValidateAll() if the designated constraints aren't met.
type ClusterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterMultiError) AllErrors() []error { return m }

// ClusterValidationError is the validation error returned by Cluster.Validate
// if the designated constraints aren't met.
type ClusterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterValidationError) ErrorName() string { return "ClusterValidationError" }

// Error satisfies the builtin error interface
func (e ClusterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCluster.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterValidationError{}

// Validate checks the field values on ClusterStatus with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ClusterStatus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterStatus with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ClusterStatusMultiError, or
// nil if none found.
func (m *ClusterStatus) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterStatus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for K8SVersion

	// no validation rules for NodeCount

	// no validation rules for NodesReady

	// no validation rules for PodCapacity

	// no validation rules for PodCount

	// no validation rules for PodsRunning

	// no validation rules for PodsPending

	// no validation rules for PodsFailed

	// no validation rules for CpuCapacityMillicores

	// no validation rules for CpuUsedMillicores

	// no validation rules for MemoryCapacityBytes

	// no validation rules for MemoryUsedBytes

	// no validation rules for WorkloadsTotal

	// no validation rules for WorkloadsHealthy

	// no validation rules for WorkloadsDegraded

	// no validation rules for WorkloadsError

	if len(errors) > 0 {
		return ClusterStatusMultiError(errors)
	}

	return nil
}

// ClusterStatusMultiError is an error wrapping multiple validation errors
// returned by ClusterStatus.ValidateAll() if the designated constraints
// aren't met.
type ClusterStatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterStatusMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterStatusMultiError) AllErrors() []error { return m }

// ClusterStatusValidationError is the validation error returned by
// ClusterStatus.Validate if the designated constraints aren't met.
type ClusterStatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterStatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterStatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterStatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterStatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterStatusValidationError) ErrorName() string { return "ClusterStatusValidationError" }

// Error satisfies the builtin error interface
func (e ClusterStatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterStatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterStatusValidationError{}

// Validate checks the field values on Workload with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Workload) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Workload with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in WorkloadMultiError, or nil
// if none found.
func (m *Workload) ValidateAll() error {
	return m.validate(true)
}

func (m *Workload) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for ClusterId

	// no validation rules for Namespace

	// no validation rules for Name

	// no validation rules for Kind

	// no validation rules for Labels

	// no validation rules for HealthStatus

	// no validation rules for StatusReason

	// no validation rules for ReplicasDesired

	// no validation rules for ReplicasReady

	// no validation rules for ReplicasAvailable

	// no validation rules for CpuRequestsMillicores

	// no validation rules for CpuLimitsMillicores

	// no validation rules for CpuUsedMillicores

	// no validation rules for MemoryRequestsBytes

	// no validation rules for MemoryLimitsBytes

	// no validation rules for MemoryUsedBytes

	for idx, item := range m.GetContainers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, WorkloadValidationError{
						field:  fmt.Sprintf("Containers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, WorkloadValidationError{
						field:  fmt.Sprintf("Containers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return WorkloadValidationError{
					field:  fmt.Sprintf("Containers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetLastUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WorkloadValidationError{
					field:  "LastUpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WorkloadValidationError{
					field:  "LastUpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WorkloadValidationError{
				field:  "LastUpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return WorkloadMultiError(errors)
	}

	return nil
}

// WorkloadMultiError is an error wrapping multiple validation errors returned
// by Workload.ValidateAll() if the designated constraints aren't met.
type WorkloadMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WorkloadMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WorkloadMultiError) AllErrors() []error { return m }

// WorkloadValidationError is the validation error returned by
// Workload.Validate if the designated constraints aren't met.
type WorkloadValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WorkloadValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WorkloadValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WorkloadValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WorkloadValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WorkloadValidationError) ErrorName() string { return "WorkloadValidationError" }

// Error satisfies the builtin error interface
func (e WorkloadValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWorkload.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WorkloadValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WorkloadValidationError{}

// Validate checks the field values on ContainerStatus with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ContainerStatus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ContainerStatus with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ContainerStatusMultiError, or nil if none found.
func (m *ContainerStatus) ValidateAll() error {
	return m.validate(true)
}

func (m *ContainerStatus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Image

	// no validation rules for RestartCount

	// no validation rules for State

	// no validation rules for Ready

	if len(errors) > 0 {
		return ContainerStatusMultiError(errors)
	}

	return nil
}

// ContainerStatusMultiError is an error wrapping multiple validation errors
// returned by ContainerStatus.ValidateAll() if the designated constraints
// aren't met.
type ContainerStatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ContainerStatusMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ContainerStatusMultiError) AllErrors() []error { return m }

// ContainerStatusValidationError is the validation error returned by
// ContainerStatus.Validate if the designated constraints aren't met.
type ContainerStatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ContainerStatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ContainerStatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ContainerStatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ContainerStatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ContainerStatusValidationError) ErrorName() string { return "ContainerStatusValidationError" }

// Error satisfies the builtin error interface
func (e ContainerStatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sContainerStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ContainerStatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ContainerStatusValidationError{}

// Validate checks the field values on ObjectReference with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ObjectReference) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ObjectReference with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ObjectReferenceMultiError, or nil if none found.
func (m *ObjectReference) ValidateAll() error {
	return m.validate(true)
}

func (m *ObjectReference) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Kind

	// no validation rules for Namespace

	// no validation rules for Name

	if len(errors) > 0 {
		return ObjectReferenceMultiError(errors)
	}

	return nil
}

// ObjectReferenceMultiError is an error wrapping multiple validation errors
// returned by ObjectReference.ValidateAll() if the designated constraints
// aren't met.
type ObjectReferenceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ObjectReferenceMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ObjectReferenceMultiError) AllErrors() []error { return m }

// ObjectReferenceValidationError is the validation error returned by
// ObjectReference.Validate if the designated constraints aren't met.
type ObjectReferenceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ObjectReferenceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ObjectReferenceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ObjectReferenceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ObjectReferenceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ObjectReferenceValidationError) ErrorName() string { return "ObjectReferenceValidationError" }

// Error satisfies the builtin error interface
func (e ObjectReferenceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sObjectReference.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ObjectReferenceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ObjectReferenceValidationError{}

// Validate checks the field values on WorkloadEvent with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *WorkloadEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WorkloadEvent with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in WorkloadEventMultiError, or
// nil if none found.
func (m *WorkloadEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *WorkloadEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	// no validation rules for Type

	// no validation rules for Reason

	if all {
		switch v := interface{}(m.GetRegarding()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WorkloadEventValidationError{
					field:  "Regarding",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WorkloadEventValidationError{
					field:  "Regarding",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRegarding()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WorkloadEventValidationError{
				field:  "Regarding",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetFirstSeen()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WorkloadEventValidationError{
					field:  "FirstSeen",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WorkloadEventValidationError{
					field:  "FirstSeen",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFirstSeen()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WorkloadEventValidationError{
				field:  "FirstSeen",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLastSeen()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WorkloadEventValidationError{
					field:  "LastSeen",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WorkloadEventValidationError{
					field:  "LastSeen",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastSeen()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WorkloadEventValidationError{
				field:  "LastSeen",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Count

	if len(errors) > 0 {
		return WorkloadEventMultiError(errors)
	}

	return nil
}

// WorkloadEventMultiError is an error wrapping multiple validation errors
// returned by WorkloadEvent.ValidateAll() if the designated constraints
// aren't met.
type WorkloadEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WorkloadEventMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WorkloadEventMultiError) AllErrors() []error { return m }

// WorkloadEventValidationError is the validation error returned by
// WorkloadEvent.Validate if the designated constraints aren't met.
type WorkloadEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WorkloadEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WorkloadEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WorkloadEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WorkloadEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WorkloadEventValidationError) ErrorName() string { return "WorkloadEventValidationError" }

// Error satisfies the builtin error interface
func (e WorkloadEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWorkloadEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WorkloadEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WorkloadEventValidationError{}

// Validate checks the field values on CreateClusterRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateClusterRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateClusterRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateClusterRequestMultiError, or nil if none found.
func (m *CreateClusterRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateClusterRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DisplayName

	// no validation rules for Labels

	if len(errors) > 0 {
		return CreateClusterRequestMultiError(errors)
	}

	return nil
}

// CreateClusterRequestMultiError is an error wrapping multiple validation
// errors returned by CreateClusterRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateClusterRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateClusterRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateClusterRequestMultiError) AllErrors() []error { return m }

// CreateClusterRequestValidationError is the validation error returned by
// CreateClusterRequest.Validate if the designated constraints aren't met.
type CreateClusterRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateClusterRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateClusterRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateClusterRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateClusterRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateClusterRequestValidationError) ErrorName() string {
	return "CreateClusterRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateClusterRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateClusterRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateClusterRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateClusterRequestValidationError{}

// Validate checks the field values on CreateClusterResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateClusterResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateClusterResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateClusterResponseMultiError, or nil if none found.
func (m *CreateClusterResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateClusterResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCluster()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateClusterResponseValidationError{
					field:  "Cluster",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateClusterResponseValidationError{
					field:  "Cluster",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCluster()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateClusterResponseValidationError{
				field:  "Cluster",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PlainTextToken

	if len(errors) > 0 {
		return CreateClusterResponseMultiError(errors)
	}

	return nil
}

// CreateClusterResponseMultiError is an error wrapping multiple validation
// errors returned by CreateClusterResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateClusterResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateClusterResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateClusterResponseMultiError) AllErrors() []error { return m }

// CreateClusterResponseValidationError is the validation error returned by
// CreateClusterResponse.Validate if the designated constraints aren't met.
type CreateClusterResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateClusterResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateClusterResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateClusterResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateClusterResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateClusterResponseValidationError) ErrorName() string {
	return "CreateClusterResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateClusterResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateClusterResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateClusterResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateClusterResponseValidationError{}

// Validate checks the field values on GetClusterRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetClusterRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetClusterRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetClusterRequestMultiError, or nil if none found.
func (m *GetClusterRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetClusterRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClusterId

	if len(errors) > 0 {
		return GetClusterRequestMultiError(errors)
	}

	return nil
}

// GetClusterRequestMultiError is an error wrapping multiple validation errors
// returned by GetClusterRequest.ValidateAll() if the designated constraints
// aren't met.
type GetClusterRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetClusterRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetClusterRequestMultiError) AllErrors() []error { return m }

// GetClusterRequestValidationError is the validation error returned by
// GetClusterRequest.Validate if the designated constraints aren't met.
type GetClusterRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetClusterRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetClusterRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetClusterRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetClusterRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetClusterRequestValidationError) ErrorName() string {
	return "GetClusterRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetClusterRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetClusterRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetClusterRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetClusterRequestValidationError{}

// Validate checks the field values on GetClusterResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetClusterResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetClusterResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetClusterResponseMultiError, or nil if none found.
func (m *GetClusterResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetClusterResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCluster()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetClusterResponseValidationError{
					field:  "Cluster",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetClusterResponseValidationError{
					field:  "Cluster",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCluster()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetClusterResponseValidationError{
				field:  "Cluster",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetClusterResponseMultiError(errors)
	}

	return nil
}

// GetClusterResponseMultiError is an error wrapping multiple validation errors
// returned by GetClusterResponse.ValidateAll() if the designated constraints
// aren't met.
type GetClusterResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetClusterResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetClusterResponseMultiError) AllErrors() []error { return m }

// GetClusterResponseValidationError is the validation error returned by
// GetClusterResponse.Validate if the designated constraints aren't met.
type GetClusterResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetClusterResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetClusterResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetClusterResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetClusterResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetClusterResponseValidationError) ErrorName() string {
	return "GetClusterResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetClusterResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetClusterResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetClusterResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetClusterResponseValidationError{}

// Validate checks the field values on ListClustersRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListClustersRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListClustersRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListClustersRequestMultiError, or nil if none found.
func (m *ListClustersRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListClustersRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PageSize

	// no validation rules for PageToken

	// no validation rules for Filter

	if len(errors) > 0 {
		return ListClustersRequestMultiError(errors)
	}

	return nil
}

// ListClustersRequestMultiError is an error wrapping multiple validation
// errors returned by ListClustersRequest.ValidateAll() if the designated
// constraints aren't met.
type ListClustersRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListClustersRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListClustersRequestMultiError) AllErrors() []error { return m }

// ListClustersRequestValidationError is the validation error returned by
// ListClustersRequest.Validate if the designated constraints aren't met.
type ListClustersRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListClustersRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListClustersRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListClustersRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListClustersRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListClustersRequestValidationError) ErrorName() string {
	return "ListClustersRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListClustersRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListClustersRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListClustersRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListClustersRequestValidationError{}

// Validate checks the field values on ListClustersResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListClustersResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListClustersResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListClustersResponseMultiError, or nil if none found.
func (m *ListClustersResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListClustersResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetClusters() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListClustersResponseValidationError{
						field:  fmt.Sprintf("Clusters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListClustersResponseValidationError{
						field:  fmt.Sprintf("Clusters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListClustersResponseValidationError{
					field:  fmt.Sprintf("Clusters[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NextPageToken

	if len(errors) > 0 {
		return ListClustersResponseMultiError(errors)
	}

	return nil
}

// ListClustersResponseMultiError is an error wrapping multiple validation
// errors returned by ListClustersResponse.ValidateAll() if the designated
// constraints aren't met.
type ListClustersResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListClustersResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListClustersResponseMultiError) AllErrors() []error { return m }

// ListClustersResponseValidationError is the validation error returned by
// ListClustersResponse.Validate if the designated constraints aren't met.
type ListClustersResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListClustersResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListClustersResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListClustersResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListClustersResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListClustersResponseValidationError) ErrorName() string {
	return "ListClustersResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListClustersResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListClustersResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListClustersResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListClustersResponseValidationError{}

// Validate checks the field values on UpdateClusterRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateClusterRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateClusterRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateClusterRequestMultiError, or nil if none found.
func (m *UpdateClusterRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateClusterRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCluster()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateClusterRequestValidationError{
					field:  "Cluster",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateClusterRequestValidationError{
					field:  "Cluster",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCluster()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateClusterRequestValidationError{
				field:  "Cluster",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateMask()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateClusterRequestValidationError{
					field:  "UpdateMask",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateClusterRequestValidationError{
					field:  "UpdateMask",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateMask()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateClusterRequestValidationError{
				field:  "UpdateMask",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateClusterRequestMultiError(errors)
	}

	return nil
}

// UpdateClusterRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateClusterRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateClusterRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateClusterRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateClusterRequestMultiError) AllErrors() []error { return m }

// UpdateClusterRequestValidationError is the validation error returned by
// UpdateClusterRequest.Validate if the designated constraints aren't met.
type UpdateClusterRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateClusterRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateClusterRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateClusterRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateClusterRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateClusterRequestValidationError) ErrorName() string {
	return "UpdateClusterRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateClusterRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateClusterRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateClusterRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateClusterRequestValidationError{}

// Validate checks the field values on UpdateClusterResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateClusterResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateClusterResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateClusterResponseMultiError, or nil if none found.
func (m *UpdateClusterResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateClusterResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCluster()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateClusterResponseValidationError{
					field:  "Cluster",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateClusterResponseValidationError{
					field:  "Cluster",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCluster()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateClusterResponseValidationError{
				field:  "Cluster",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateClusterResponseMultiError(errors)
	}

	return nil
}

// UpdateClusterResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateClusterResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateClusterResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateClusterResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateClusterResponseMultiError) AllErrors() []error { return m }

// UpdateClusterResponseValidationError is the validation error returned by
// UpdateClusterResponse.Validate if the designated constraints aren't met.
type UpdateClusterResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateClusterResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateClusterResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateClusterResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateClusterResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateClusterResponseValidationError) ErrorName() string {
	return "UpdateClusterResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateClusterResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateClusterResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateClusterResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateClusterResponseValidationError{}

// Validate checks the field values on DeleteClusterRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteClusterRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteClusterRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteClusterRequestMultiError, or nil if none found.
func (m *DeleteClusterRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteClusterRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClusterId

	if len(errors) > 0 {
		return DeleteClusterRequestMultiError(errors)
	}

	return nil
}

// DeleteClusterRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteClusterRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteClusterRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteClusterRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteClusterRequestMultiError) AllErrors() []error { return m }

// DeleteClusterRequestValidationError is the validation error returned by
// DeleteClusterRequest.Validate if the designated constraints aren't met.
type DeleteClusterRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteClusterRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteClusterRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteClusterRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteClusterRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteClusterRequestValidationError) ErrorName() string {
	return "DeleteClusterRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteClusterRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteClusterRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteClusterRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteClusterRequestValidationError{}

// Validate checks the field values on DeleteClusterResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteClusterResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteClusterResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteClusterResponseMultiError, or nil if none found.
func (m *DeleteClusterResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteClusterResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteClusterResponseMultiError(errors)
	}

	return nil
}

// DeleteClusterResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteClusterResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteClusterResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteClusterResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteClusterResponseMultiError) AllErrors() []error { return m }

// DeleteClusterResponseValidationError is the validation error returned by
// DeleteClusterResponse.Validate if the designated constraints aren't met.
type DeleteClusterResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteClusterResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteClusterResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteClusterResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteClusterResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteClusterResponseValidationError) ErrorName() string {
	return "DeleteClusterResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteClusterResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteClusterResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteClusterResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteClusterResponseValidationError{}

// Validate checks the field values on GetClusterStatusRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetClusterStatusRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetClusterStatusRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetClusterStatusRequestMultiError, or nil if none found.
func (m *GetClusterStatusRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetClusterStatusRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClusterId

	if len(errors) > 0 {
		return GetClusterStatusRequestMultiError(errors)
	}

	return nil
}

// GetClusterStatusRequestMultiError is an error wrapping multiple validation
// errors returned by GetClusterStatusRequest.ValidateAll() if the designated
// constraints aren't met.
type GetClusterStatusRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetClusterStatusRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetClusterStatusRequestMultiError) AllErrors() []error { return m }

// GetClusterStatusRequestValidationError is the validation error returned by
// GetClusterStatusRequest.Validate if the designated constraints aren't met.
type GetClusterStatusRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetClusterStatusRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetClusterStatusRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetClusterStatusRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetClusterStatusRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetClusterStatusRequestValidationError) ErrorName() string {
	return "GetClusterStatusRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetClusterStatusRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetClusterStatusRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetClusterStatusRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetClusterStatusRequestValidationError{}

// Validate checks the field values on GetClusterStatusResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetClusterStatusResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetClusterStatusResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetClusterStatusResponseMultiError, or nil if none found.
func (m *GetClusterStatusResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetClusterStatusResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for HealthStatus

	if all {
		switch v := interface{}(m.GetStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetClusterStatusResponseValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetClusterStatusResponseValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetClusterStatusResponseValidationError{
				field:  "Status",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetReportedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetClusterStatusResponseValidationError{
					field:  "ReportedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetClusterStatusResponseValidationError{
					field:  "ReportedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReportedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetClusterStatusResponseValidationError{
				field:  "ReportedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetClusterStatusResponseMultiError(errors)
	}

	return nil
}

// GetClusterStatusResponseMultiError is an error wrapping multiple validation
// errors returned by GetClusterStatusResponse.ValidateAll() if the designated
// constraints aren't met.
type GetClusterStatusResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetClusterStatusResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetClusterStatusResponseMultiError) AllErrors() []error { return m }

// GetClusterStatusResponseValidationError is the validation error returned by
// GetClusterStatusResponse.Validate if the designated constraints aren't met.
type GetClusterStatusResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetClusterStatusResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetClusterStatusResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetClusterStatusResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetClusterStatusResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetClusterStatusResponseValidationError) ErrorName() string {
	return "GetClusterStatusResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetClusterStatusResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetClusterStatusResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetClusterStatusResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetClusterStatusResponseValidationError{}

// Validate checks the field values on ReportClusterStatusRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReportClusterStatusRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReportClusterStatusRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReportClusterStatusRequestMultiError, or nil if none found.
func (m *ReportClusterStatusRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ReportClusterStatusRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClusterId

	if all {
		switch v := interface{}(m.GetStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReportClusterStatusRequestValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReportClusterStatusRequestValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReportClusterStatusRequestValidationError{
				field:  "Status",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetWorkloads() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReportClusterStatusRequestValidationError{
						field:  fmt.Sprintf("Workloads[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReportClusterStatusRequestValidationError{
						field:  fmt.Sprintf("Workloads[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReportClusterStatusRequestValidationError{
					field:  fmt.Sprintf("Workloads[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetEvents() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReportClusterStatusRequestValidationError{
						field:  fmt.Sprintf("Events[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReportClusterStatusRequestValidationError{
						field:  fmt.Sprintf("Events[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReportClusterStatusRequestValidationError{
					field:  fmt.Sprintf("Events[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetReportedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReportClusterStatusRequestValidationError{
					field:  "ReportedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReportClusterStatusRequestValidationError{
					field:  "ReportedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReportedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReportClusterStatusRequestValidationError{
				field:  "ReportedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReportClusterStatusRequestMultiError(errors)
	}

	return nil
}

// ReportClusterStatusRequestMultiError is an error wrapping multiple
// validation errors returned by ReportClusterStatusRequest.ValidateAll() if
// the designated constraints aren't met.
type ReportClusterStatusRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReportClusterStatusRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReportClusterStatusRequestMultiError) AllErrors() []error { return m }

// ReportClusterStatusRequestValidationError is the validation error returned
// by ReportClusterStatusRequest.Validate if the designated constraints aren't met.
type ReportClusterStatusRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReportClusterStatusRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReportClusterStatusRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReportClusterStatusRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReportClusterStatusRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReportClusterStatusRequestValidationError) ErrorName() string {
	return "ReportClusterStatusRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ReportClusterStatusRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReportClusterStatusRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReportClusterStatusRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReportClusterStatusRequestValidationError{}

// Validate checks the field values on WorkloadStatus with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *WorkloadStatus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WorkloadStatus with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in WorkloadStatusMultiError,
// or nil if none found.
func (m *WorkloadStatus) ValidateAll() error {
	return m.validate(true)
}

func (m *WorkloadStatus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Namespace

	// no validation rules for Name

	// no validation rules for Kind

	// no validation rules for Labels

	// no validation rules for ReplicasDesired

	// no validation rules for ReplicasReady

	// no validation rules for ReplicasAvailable

	// no validation rules for CpuRequestsMillicores

	// no validation rules for CpuLimitsMillicores

	// no validation rules for CpuUsedMillicores

	// no validation rules for MemoryRequestsBytes

	// no validation rules for MemoryLimitsBytes

	// no validation rules for MemoryUsedBytes

	// no validation rules for HealthStatus

	for idx, item := range m.GetContainers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, WorkloadStatusValidationError{
						field:  fmt.Sprintf("Containers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, WorkloadStatusValidationError{
						field:  fmt.Sprintf("Containers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return WorkloadStatusValidationError{
					field:  fmt.Sprintf("Containers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return WorkloadStatusMultiError(errors)
	}

	return nil
}

// WorkloadStatusMultiError is an error wrapping multiple validation errors
// returned by WorkloadStatus.ValidateAll() if the designated constraints
// aren't met.
type WorkloadStatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WorkloadStatusMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WorkloadStatusMultiError) AllErrors() []error { return m }

// WorkloadStatusValidationError is the validation error returned by
// WorkloadStatus.Validate if the designated constraints aren't met.
type WorkloadStatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WorkloadStatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WorkloadStatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WorkloadStatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WorkloadStatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WorkloadStatusValidationError) ErrorName() string { return "WorkloadStatusValidationError" }

// Error satisfies the builtin error interface
func (e WorkloadStatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWorkloadStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WorkloadStatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WorkloadStatusValidationError{}

// Validate checks the field values on ReportClusterStatusResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReportClusterStatusResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReportClusterStatusResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReportClusterStatusResponseMultiError, or nil if none found.
func (m *ReportClusterStatusResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ReportClusterStatusResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Ack

	// no validation rules for NextPushSeconds

	if len(errors) > 0 {
		return ReportClusterStatusResponseMultiError(errors)
	}

	return nil
}

// ReportClusterStatusResponseMultiError is an error wrapping multiple
// validation errors returned by ReportClusterStatusResponse.ValidateAll() if
// the designated constraints aren't met.
type ReportClusterStatusResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReportClusterStatusResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReportClusterStatusResponseMultiError) AllErrors() []error { return m }

// ReportClusterStatusResponseValidationError is the validation error returned
// by ReportClusterStatusResponse.Validate if the designated constraints
// aren't met.
type ReportClusterStatusResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReportClusterStatusResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReportClusterStatusResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReportClusterStatusResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReportClusterStatusResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReportClusterStatusResponseValidationError) ErrorName() string {
	return "ReportClusterStatusResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ReportClusterStatusResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReportClusterStatusResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReportClusterStatusResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReportClusterStatusResponseValidationError{}

// Validate checks the field values on ListWorkloadsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListWorkloadsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListWorkloadsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListWorkloadsRequestMultiError, or nil if none found.
func (m *ListWorkloadsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListWorkloadsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClusterId

	// no validation rules for PageSize

	// no validation rules for PageToken

	// no validation rules for Filter

	if len(errors) > 0 {
		return ListWorkloadsRequestMultiError(errors)
	}

	return nil
}

// ListWorkloadsRequestMultiError is an error wrapping multiple validation
// errors returned by ListWorkloadsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListWorkloadsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListWorkloadsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListWorkloadsRequestMultiError) AllErrors() []error { return m }

// ListWorkloadsRequestValidationError is the validation error returned by
// ListWorkloadsRequest.Validate if the designated constraints aren't met.
type ListWorkloadsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListWorkloadsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListWorkloadsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListWorkloadsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListWorkloadsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListWorkloadsRequestValidationError) ErrorName() string {
	return "ListWorkloadsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListWorkloadsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListWorkloadsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListWorkloadsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListWorkloadsRequestValidationError{}

// Validate checks the field values on ListWorkloadsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListWorkloadsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListWorkloadsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListWorkloadsResponseMultiError, or nil if none found.
func (m *ListWorkloadsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListWorkloadsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetWorkloads() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListWorkloadsResponseValidationError{
						field:  fmt.Sprintf("Workloads[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListWorkloadsResponseValidationError{
						field:  fmt.Sprintf("Workloads[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListWorkloadsResponseValidationError{
					field:  fmt.Sprintf("Workloads[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NextPageToken

	if len(errors) > 0 {
		return ListWorkloadsResponseMultiError(errors)
	}

	return nil
}

// ListWorkloadsResponseMultiError is an error wrapping multiple validation
// errors returned by ListWorkloadsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListWorkloadsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListWorkloadsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListWorkloadsResponseMultiError) AllErrors() []error { return m }

// ListWorkloadsResponseValidationError is the validation error returned by
// ListWorkloadsResponse.Validate if the designated constraints aren't met.
type ListWorkloadsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListWorkloadsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListWorkloadsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListWorkloadsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListWorkloadsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListWorkloadsResponseValidationError) ErrorName() string {
	return "ListWorkloadsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListWorkloadsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListWorkloadsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListWorkloadsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListWorkloadsResponseValidationError{}

// Validate checks the field values on ReportWorkloadStatusRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReportWorkloadStatusRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReportWorkloadStatusRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReportWorkloadStatusRequestMultiError, or nil if none found.
func (m *ReportWorkloadStatusRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ReportWorkloadStatusRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClusterId

	for idx, item := range m.GetWorkloads() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReportWorkloadStatusRequestValidationError{
						field:  fmt.Sprintf("Workloads[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReportWorkloadStatusRequestValidationError{
						field:  fmt.Sprintf("Workloads[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReportWorkloadStatusRequestValidationError{
					field:  fmt.Sprintf("Workloads[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetReportedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReportWorkloadStatusRequestValidationError{
					field:  "ReportedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReportWorkloadStatusRequestValidationError{
					field:  "ReportedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReportedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReportWorkloadStatusRequestValidationError{
				field:  "ReportedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReportWorkloadStatusRequestMultiError(errors)
	}

	return nil
}

// ReportWorkloadStatusRequestMultiError is an error wrapping multiple
// validation errors returned by ReportWorkloadStatusRequest.ValidateAll() if
// the designated constraints aren't met.
type ReportWorkloadStatusRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReportWorkloadStatusRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReportWorkloadStatusRequestMultiError) AllErrors() []error { return m }

// ReportWorkloadStatusRequestValidationError is the validation error returned
// by ReportWorkloadStatusRequest.Validate if the designated constraints
// aren't met.
type ReportWorkloadStatusRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReportWorkloadStatusRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReportWorkloadStatusRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReportWorkloadStatusRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReportWorkloadStatusRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReportWorkloadStatusRequestValidationError) ErrorName() string {
	return "ReportWorkloadStatusRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ReportWorkloadStatusRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReportWorkloadStatusRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReportWorkloadStatusRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReportWorkloadStatusRequestValidationError{}

// Validate checks the field values on ReportWorkloadStatusResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReportWorkloadStatusResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReportWorkloadStatusResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReportWorkloadStatusResponseMultiError, or nil if none found.
func (m *ReportWorkloadStatusResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ReportWorkloadStatusResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Ack

	if len(errors) > 0 {
		return ReportWorkloadStatusResponseMultiError(errors)
	}

	return nil
}

// ReportWorkloadStatusResponseMultiError is an error wrapping multiple
// validation errors returned by ReportWorkloadStatusResponse.ValidateAll() if
// the designated constraints aren't met.
type ReportWorkloadStatusResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReportWorkloadStatusResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReportWorkloadStatusResponseMultiError) AllErrors() []error { return m }

// ReportWorkloadStatusResponseValidationError is the validation error returned
// by ReportWorkloadStatusResponse.Validate if the designated constraints
// aren't met.
type ReportWorkloadStatusResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReportWorkloadStatusResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReportWorkloadStatusResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReportWorkloadStatusResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReportWorkloadStatusResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReportWorkloadStatusResponseValidationError) ErrorName() string {
	return "ReportWorkloadStatusResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ReportWorkloadStatusResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReportWorkloadStatusResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReportWorkloadStatusResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReportWorkloadStatusResponseValidationError{}

// Validate checks the field values on CreateClusterTokenRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateClusterTokenRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateClusterTokenRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateClusterTokenRequestMultiError, or nil if none found.
func (m *CreateClusterTokenRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateClusterTokenRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClusterId

	// no validation rules for DisplayName

	if all {
		switch v := interface{}(m.GetExpiresAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateClusterTokenRequestValidationError{
					field:  "ExpiresAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateClusterTokenRequestValidationError{
					field:  "ExpiresAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpiresAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateClusterTokenRequestValidationError{
				field:  "ExpiresAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateClusterTokenRequestMultiError(errors)
	}

	return nil
}

// CreateClusterTokenRequestMultiError is an error wrapping multiple validation
// errors returned by CreateClusterTokenRequest.ValidateAll() if the
// designated constraints aren't met.
type CreateClusterTokenRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateClusterTokenRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateClusterTokenRequestMultiError) AllErrors() []error { return m }

// CreateClusterTokenRequestValidationError is the validation error returned by
// CreateClusterTokenRequest.Validate if the designated constraints aren't met.
type CreateClusterTokenRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateClusterTokenRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateClusterTokenRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateClusterTokenRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateClusterTokenRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateClusterTokenRequestValidationError) ErrorName() string {
	return "CreateClusterTokenRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateClusterTokenRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateClusterTokenRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateClusterTokenRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateClusterTokenRequestValidationError{}

// Validate checks the field values on CreateClusterTokenResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateClusterTokenResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateClusterTokenResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateClusterTokenResponseMultiError, or nil if none found.
func (m *CreateClusterTokenResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateClusterTokenResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAccessToken()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateClusterTokenResponseValidationError{
					field:  "AccessToken",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateClusterTokenResponseValidationError{
					field:  "AccessToken",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAccessToken()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateClusterTokenResponseValidationError{
				field:  "AccessToken",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PlainTextToken

	if len(errors) > 0 {
		return CreateClusterTokenResponseMultiError(errors)
	}

	return nil
}

// CreateClusterTokenResponseMultiError is an error wrapping multiple
// validation errors returned by CreateClusterTokenResponse.ValidateAll() if
// the designated constraints aren't met.
type CreateClusterTokenResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateClusterTokenResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateClusterTokenResponseMultiError) AllErrors() []error { return m }

// CreateClusterTokenResponseValidationError is the validation error returned
// by CreateClusterTokenResponse.Validate if the designated constraints aren't met.
type CreateClusterTokenResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateClusterTokenResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateClusterTokenResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateClusterTokenResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateClusterTokenResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateClusterTokenResponseValidationError) ErrorName() string {
	return "CreateClusterTokenResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateClusterTokenResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateClusterTokenResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateClusterTokenResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateClusterTokenResponseValidationError{}

// Validate checks the field values on ListClusterTokensRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListClusterTokensRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListClusterTokensRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListClusterTokensRequestMultiError, or nil if none found.
func (m *ListClusterTokensRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListClusterTokensRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClusterId

	// no validation rules for PageSize

	// no validation rules for PageToken

	// no validation rules for Filter

	if len(errors) > 0 {
		return ListClusterTokensRequestMultiError(errors)
	}

	return nil
}

// ListClusterTokensRequestMultiError is an error wrapping multiple validation
// errors returned by ListClusterTokensRequest.ValidateAll() if the designated
// constraints aren't met.
type ListClusterTokensRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListClusterTokensRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListClusterTokensRequestMultiError) AllErrors() []error { return m }

// ListClusterTokensRequestValidationError is the validation error returned by
// ListClusterTokensRequest.Validate if the designated constraints aren't met.
type ListClusterTokensRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListClusterTokensRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListClusterTokensRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListClusterTokensRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListClusterTokensRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListClusterTokensRequestValidationError) ErrorName() string {
	return "ListClusterTokensRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListClusterTokensRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListClusterTokensRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListClusterTokensRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListClusterTokensRequestValidationError{}

// Validate checks the field values on ListClusterTokensResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListClusterTokensResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListClusterTokensResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListClusterTokensResponseMultiError, or nil if none found.
func (m *ListClusterTokensResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListClusterTokensResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAccessTokens() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListClusterTokensResponseValidationError{
						field:  fmt.Sprintf("AccessTokens[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListClusterTokensResponseValidationError{
						field:  fmt.Sprintf("AccessTokens[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListClusterTokensResponseValidationError{
					field:  fmt.Sprintf("AccessTokens[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NextPageToken

	if len(errors) > 0 {
		return ListClusterTokensResponseMultiError(errors)
	}

	return nil
}

// ListClusterTokensResponseMultiError is an error wrapping multiple validation
// errors returned by ListClusterTokensResponse.ValidateAll() if the
// designated constraints aren't met.
type ListClusterTokensResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListClusterTokensResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListClusterTokensResponseMultiError) AllErrors() []error { return m }

// ListClusterTokensResponseValidationError is the validation error returned by
// ListClusterTokensResponse.Validate if the designated constraints aren't met.
type ListClusterTokensResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListClusterTokensResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListClusterTokensResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListClusterTokensResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListClusterTokensResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListClusterTokensResponseValidationError) ErrorName() string {
	return "ListClusterTokensResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListClusterTokensResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListClusterTokensResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListClusterTokensResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListClusterTokensResponseValidationError{}

// Validate checks the field values on GetClusterTokenRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetClusterTokenRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetClusterTokenRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetClusterTokenRequestMultiError, or nil if none found.
func (m *GetClusterTokenRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetClusterTokenRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClusterId

	// no validation rules for TokenId

	if len(errors) > 0 {
		return GetClusterTokenRequestMultiError(errors)
	}

	return nil
}

// GetClusterTokenRequestMultiError is an error wrapping multiple validation
// errors returned by GetClusterTokenRequest.ValidateAll() if the designated
// constraints aren't met.
type GetClusterTokenRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetClusterTokenRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetClusterTokenRequestMultiError) AllErrors() []error { return m }

// GetClusterTokenRequestValidationError is the validation error returned by
// GetClusterTokenRequest.Validate if the designated constraints aren't met.
type GetClusterTokenRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetClusterTokenRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetClusterTokenRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetClusterTokenRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetClusterTokenRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetClusterTokenRequestValidationError) ErrorName() string {
	return "GetClusterTokenRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetClusterTokenRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetClusterTokenRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetClusterTokenRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetClusterTokenRequestValidationError{}

// Validate checks the field values on GetClusterTokenResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetClusterTokenResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetClusterTokenResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetClusterTokenResponseMultiError, or nil if none found.
func (m *GetClusterTokenResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetClusterTokenResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAccessToken()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetClusterTokenResponseValidationError{
					field:  "AccessToken",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetClusterTokenResponseValidationError{
					field:  "AccessToken",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAccessToken()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetClusterTokenResponseValidationError{
				field:  "AccessToken",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetClusterTokenResponseMultiError(errors)
	}

	return nil
}

// GetClusterTokenResponseMultiError is an error wrapping multiple validation
// errors returned by GetClusterTokenResponse.ValidateAll() if the designated
// constraints aren't met.
type GetClusterTokenResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetClusterTokenResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetClusterTokenResponseMultiError) AllErrors() []error { return m }

// GetClusterTokenResponseValidationError is the validation error returned by
// GetClusterTokenResponse.Validate if the designated constraints aren't met.
type GetClusterTokenResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetClusterTokenResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetClusterTokenResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetClusterTokenResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetClusterTokenResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetClusterTokenResponseValidationError) ErrorName() string {
	return "GetClusterTokenResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetClusterTokenResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetClusterTokenResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetClusterTokenResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetClusterTokenResponseValidationError{}

// Validate checks the field values on RevokeClusterTokenRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RevokeClusterTokenRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RevokeClusterTokenRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RevokeClusterTokenRequestMultiError, or nil if none found.
func (m *RevokeClusterTokenRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RevokeClusterTokenRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClusterId

	// no validation rules for TokenId

	if len(errors) > 0 {
		return RevokeClusterTokenRequestMultiError(errors)
	}

	return nil
}

// RevokeClusterTokenRequestMultiError is an error wrapping multiple validation
// errors returned by RevokeClusterTokenRequest.ValidateAll() if the
// designated constraints aren't met.
type RevokeClusterTokenRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RevokeClusterTokenRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RevokeClusterTokenRequestMultiError) AllErrors() []error { return m }

// RevokeClusterTokenRequestValidationError is the validation error returned by
// RevokeClusterTokenRequest.Validate if the designated constraints aren't met.
type RevokeClusterTokenRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RevokeClusterTokenRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RevokeClusterTokenRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RevokeClusterTokenRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RevokeClusterTokenRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RevokeClusterTokenRequestValidationError) ErrorName() string {
	return "RevokeClusterTokenRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RevokeClusterTokenRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRevokeClusterTokenRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RevokeClusterTokenRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RevokeClusterTokenRequestValidationError{}

// Validate checks the field values on RevokeClusterTokenResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RevokeClusterTokenResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RevokeClusterTokenResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RevokeClusterTokenResponseMultiError, or nil if none found.
func (m *RevokeClusterTokenResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RevokeClusterTokenResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAccessToken()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RevokeClusterTokenResponseValidationError{
					field:  "AccessToken",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RevokeClusterTokenResponseValidationError{
					field:  "AccessToken",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAccessToken()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RevokeClusterTokenResponseValidationError{
				field:  "AccessToken",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RevokeClusterTokenResponseMultiError(errors)
	}

	return nil
}

// RevokeClusterTokenResponseMultiError is an error wrapping multiple
// validation errors returned by RevokeClusterTokenResponse.ValidateAll() if
// the designated constraints aren't met.
type RevokeClusterTokenResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RevokeClusterTokenResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RevokeClusterTokenResponseMultiError) AllErrors() []error { return m }

// RevokeClusterTokenResponseValidationError is the validation error returned
// by RevokeClusterTokenResponse.Validate if the designated constraints aren't met.
type RevokeClusterTokenResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RevokeClusterTokenResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RevokeClusterTokenResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RevokeClusterTokenResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RevokeClusterTokenResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RevokeClusterTokenResponseValidationError) ErrorName() string {
	return "RevokeClusterTokenResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RevokeClusterTokenResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRevokeClusterTokenResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RevokeClusterTokenResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RevokeClusterTokenResponseValidationError{}
