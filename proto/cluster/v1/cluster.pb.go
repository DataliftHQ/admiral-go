// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        (unknown)
// source: cluster/v1/cluster.proto

package clusterv1

import (
	_ "buf.build/gen/go/bufbuild/protovalidate/protocolbuffers/go/buf/validate"
	v1 "go.admiral.io/sdk/proto/accesstoken/v1"
	_ "go.admiral.io/sdk/proto/authz/v1"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	fieldmaskpb "google.golang.org/protobuf/types/known/fieldmaskpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// ClusterHealthStatus represents the derived health state of a cluster.
// The status is computed from agent connectivity, node readiness, and workload health.
type ClusterHealthStatus int32

const (
	// Default value. Must not be used.
	ClusterHealthStatus_CLUSTER_HEALTH_STATUS_UNSPECIFIED ClusterHealthStatus = 0
	// Cluster record exists but no agent has registered yet.
	ClusterHealthStatus_CLUSTER_HEALTH_STATUS_PENDING ClusterHealthStatus = 1
	// Agent connected, all nodes ready, less than 10% workloads degraded.
	ClusterHealthStatus_CLUSTER_HEALTH_STATUS_HEALTHY ClusterHealthStatus = 2
	// Agent connected, some nodes not ready or workloads in error/degraded state.
	ClusterHealthStatus_CLUSTER_HEALTH_STATUS_DEGRADED ClusterHealthStatus = 3
	// Agent connected, more than 25% nodes not ready or workloads in error state.
	ClusterHealthStatus_CLUSTER_HEALTH_STATUS_ERROR ClusterHealthStatus = 4
	// No heartbeat received within 3x the heartbeat interval.
	ClusterHealthStatus_CLUSTER_HEALTH_STATUS_UNREACHABLE ClusterHealthStatus = 5
)

// Enum value maps for ClusterHealthStatus.
var (
	ClusterHealthStatus_name = map[int32]string{
		0: "CLUSTER_HEALTH_STATUS_UNSPECIFIED",
		1: "CLUSTER_HEALTH_STATUS_PENDING",
		2: "CLUSTER_HEALTH_STATUS_HEALTHY",
		3: "CLUSTER_HEALTH_STATUS_DEGRADED",
		4: "CLUSTER_HEALTH_STATUS_ERROR",
		5: "CLUSTER_HEALTH_STATUS_UNREACHABLE",
	}
	ClusterHealthStatus_value = map[string]int32{
		"CLUSTER_HEALTH_STATUS_UNSPECIFIED": 0,
		"CLUSTER_HEALTH_STATUS_PENDING":     1,
		"CLUSTER_HEALTH_STATUS_HEALTHY":     2,
		"CLUSTER_HEALTH_STATUS_DEGRADED":    3,
		"CLUSTER_HEALTH_STATUS_ERROR":       4,
		"CLUSTER_HEALTH_STATUS_UNREACHABLE": 5,
	}
)

func (x ClusterHealthStatus) Enum() *ClusterHealthStatus {
	p := new(ClusterHealthStatus)
	*p = x
	return p
}

func (x ClusterHealthStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ClusterHealthStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_cluster_v1_cluster_proto_enumTypes[0].Descriptor()
}

func (ClusterHealthStatus) Type() protoreflect.EnumType {
	return &file_cluster_v1_cluster_proto_enumTypes[0]
}

func (x ClusterHealthStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ClusterHealthStatus.Descriptor instead.
func (ClusterHealthStatus) EnumDescriptor() ([]byte, []int) {
	return file_cluster_v1_cluster_proto_rawDescGZIP(), []int{0}
}

// WorkloadHealthStatus represents the derived health state of a single workload.
type WorkloadHealthStatus int32

const (
	// Default value. Must not be used.
	WorkloadHealthStatus_WORKLOAD_HEALTH_STATUS_UNSPECIFIED WorkloadHealthStatus = 0
	// All desired replicas ready, no CrashLoopBackOff, restarts stable.
	WorkloadHealthStatus_WORKLOAD_HEALTH_STATUS_HEALTHY WorkloadHealthStatus = 1
	// Some replicas not ready, restarts increasing, or pods pending over 5 minutes.
	WorkloadHealthStatus_WORKLOAD_HEALTH_STATUS_DEGRADED WorkloadHealthStatus = 2
	// Zero ready replicas, all containers CrashLoopBackOff, or deployment stuck.
	WorkloadHealthStatus_WORKLOAD_HEALTH_STATUS_ERROR WorkloadHealthStatus = 3
)

// Enum value maps for WorkloadHealthStatus.
var (
	WorkloadHealthStatus_name = map[int32]string{
		0: "WORKLOAD_HEALTH_STATUS_UNSPECIFIED",
		1: "WORKLOAD_HEALTH_STATUS_HEALTHY",
		2: "WORKLOAD_HEALTH_STATUS_DEGRADED",
		3: "WORKLOAD_HEALTH_STATUS_ERROR",
	}
	WorkloadHealthStatus_value = map[string]int32{
		"WORKLOAD_HEALTH_STATUS_UNSPECIFIED": 0,
		"WORKLOAD_HEALTH_STATUS_HEALTHY":     1,
		"WORKLOAD_HEALTH_STATUS_DEGRADED":    2,
		"WORKLOAD_HEALTH_STATUS_ERROR":       3,
	}
)

func (x WorkloadHealthStatus) Enum() *WorkloadHealthStatus {
	p := new(WorkloadHealthStatus)
	*p = x
	return p
}

func (x WorkloadHealthStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (WorkloadHealthStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_cluster_v1_cluster_proto_enumTypes[1].Descriptor()
}

func (WorkloadHealthStatus) Type() protoreflect.EnumType {
	return &file_cluster_v1_cluster_proto_enumTypes[1]
}

func (x WorkloadHealthStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use WorkloadHealthStatus.Descriptor instead.
func (WorkloadHealthStatus) EnumDescriptor() ([]byte, []int) {
	return file_cluster_v1_cluster_proto_rawDescGZIP(), []int{1}
}

// Cluster represents a registered Kubernetes cluster within a tenant.
type Cluster struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Unique identifier for the cluster (UUID).
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Tenant this cluster belongs to (UUID).
	TenantId string `protobuf:"bytes,2,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`
	// Human-readable name (e.g., "prod-us-east-1"). Unique within the tenant.
	DisplayName string `protobuf:"bytes,3,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	// Arbitrary key-value labels for organizing and filtering clusters
	// (e.g., `{"region": "us-east-1", "cloud": "aws"}`).
	Labels map[string]string `protobuf:"bytes,4,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The Kubernetes kube-system namespace UID, bound at agent registration
	// using a first-write-wins strategy. Used to detect when a token is
	// accidentally deployed to a different physical cluster.
	ClusterUid string `protobuf:"bytes,5,opt,name=cluster_uid,json=clusterUid,proto3" json:"cluster_uid,omitempty"`
	// Derived health status based on agent connectivity and workload state.
	HealthStatus ClusterHealthStatus `protobuf:"varint,6,opt,name=health_status,json=healthStatus,proto3,enum=admiral.api.cluster.v1.ClusterHealthStatus" json:"health_status,omitempty"`
	// When the cluster record was created.
	CreatedAt *timestamppb.Timestamp `protobuf:"bytes,7,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	// When the cluster record was last updated.
	UpdatedAt     *timestamppb.Timestamp `protobuf:"bytes,8,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Cluster) Reset() {
	*x = Cluster{}
	mi := &file_cluster_v1_cluster_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Cluster) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Cluster) ProtoMessage() {}

func (x *Cluster) ProtoReflect() protoreflect.Message {
	mi := &file_cluster_v1_cluster_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Cluster.ProtoReflect.Descriptor instead.
func (*Cluster) Descriptor() ([]byte, []int) {
	return file_cluster_v1_cluster_proto_rawDescGZIP(), []int{0}
}

func (x *Cluster) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *Cluster) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

func (x *Cluster) GetDisplayName() string {
	if x != nil {
		return x.DisplayName
	}
	return ""
}

func (x *Cluster) GetLabels() map[string]string {
	if x != nil {
		return x.Labels
	}
	return nil
}

func (x *Cluster) GetClusterUid() string {
	if x != nil {
		return x.ClusterUid
	}
	return ""
}

func (x *Cluster) GetHealthStatus() ClusterHealthStatus {
	if x != nil {
		return x.HealthStatus
	}
	return ClusterHealthStatus_CLUSTER_HEALTH_STATUS_UNSPECIFIED
}

func (x *Cluster) GetCreatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.CreatedAt
	}
	return nil
}

func (x *Cluster) GetUpdatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.UpdatedAt
	}
	return nil
}

// ClusterStatus contains the raw telemetry metrics for a cluster, as reported
// by the K8s agent. This message is used in both the push payload
// (ReportClusterStatusRequest) and the read response (GetClusterStatusResponse).
//
// Server-derived fields (health_status, agent connectivity) are NOT included
// here â€” they live on the Cluster and Agent records respectively, and are
// returned alongside this message in GetClusterStatusResponse.
type ClusterStatus struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Kubernetes version reported by the agent (e.g., "1.29.2").
	K8SVersion string `protobuf:"bytes,1,opt,name=k8s_version,json=k8sVersion,proto3" json:"k8s_version,omitempty"`
	// Total number of nodes in the cluster.
	NodeCount int32 `protobuf:"varint,2,opt,name=node_count,json=nodeCount,proto3" json:"node_count,omitempty"`
	// Number of nodes in Ready condition.
	NodesReady int32 `protobuf:"varint,3,opt,name=nodes_ready,json=nodesReady,proto3" json:"nodes_ready,omitempty"`
	// Maximum number of pods the cluster can schedule.
	PodCapacity int32 `protobuf:"varint,4,opt,name=pod_capacity,json=podCapacity,proto3" json:"pod_capacity,omitempty"`
	// Total number of pods across all namespaces.
	PodCount int32 `protobuf:"varint,5,opt,name=pod_count,json=podCount,proto3" json:"pod_count,omitempty"`
	// Number of pods in Running phase.
	PodsRunning int32 `protobuf:"varint,6,opt,name=pods_running,json=podsRunning,proto3" json:"pods_running,omitempty"`
	// Number of pods in Pending phase.
	PodsPending int32 `protobuf:"varint,7,opt,name=pods_pending,json=podsPending,proto3" json:"pods_pending,omitempty"`
	// Number of pods in Failed phase.
	PodsFailed int32 `protobuf:"varint,8,opt,name=pods_failed,json=podsFailed,proto3" json:"pods_failed,omitempty"`
	// Total CPU capacity across all nodes, in millicores.
	CpuCapacityMillicores int64 `protobuf:"varint,9,opt,name=cpu_capacity_millicores,json=cpuCapacityMillicores,proto3" json:"cpu_capacity_millicores,omitempty"`
	// Current CPU usage across all nodes, in millicores.
	CpuUsedMillicores int64 `protobuf:"varint,10,opt,name=cpu_used_millicores,json=cpuUsedMillicores,proto3" json:"cpu_used_millicores,omitempty"`
	// Total memory capacity across all nodes, in bytes.
	MemoryCapacityBytes int64 `protobuf:"varint,11,opt,name=memory_capacity_bytes,json=memoryCapacityBytes,proto3" json:"memory_capacity_bytes,omitempty"`
	// Current memory usage across all nodes, in bytes.
	MemoryUsedBytes int64 `protobuf:"varint,12,opt,name=memory_used_bytes,json=memoryUsedBytes,proto3" json:"memory_used_bytes,omitempty"`
	// Total number of tracked workloads.
	WorkloadsTotal int32 `protobuf:"varint,13,opt,name=workloads_total,json=workloadsTotal,proto3" json:"workloads_total,omitempty"`
	// Number of workloads in healthy state.
	WorkloadsHealthy int32 `protobuf:"varint,14,opt,name=workloads_healthy,json=workloadsHealthy,proto3" json:"workloads_healthy,omitempty"`
	// Number of workloads in degraded state.
	WorkloadsDegraded int32 `protobuf:"varint,15,opt,name=workloads_degraded,json=workloadsDegraded,proto3" json:"workloads_degraded,omitempty"`
	// Number of workloads in error state.
	WorkloadsError int32 `protobuf:"varint,16,opt,name=workloads_error,json=workloadsError,proto3" json:"workloads_error,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *ClusterStatus) Reset() {
	*x = ClusterStatus{}
	mi := &file_cluster_v1_cluster_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClusterStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClusterStatus) ProtoMessage() {}

func (x *ClusterStatus) ProtoReflect() protoreflect.Message {
	mi := &file_cluster_v1_cluster_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClusterStatus.ProtoReflect.Descriptor instead.
func (*ClusterStatus) Descriptor() ([]byte, []int) {
	return file_cluster_v1_cluster_proto_rawDescGZIP(), []int{1}
}

func (x *ClusterStatus) GetK8SVersion() string {
	if x != nil {
		return x.K8SVersion
	}
	return ""
}

func (x *ClusterStatus) GetNodeCount() int32 {
	if x != nil {
		return x.NodeCount
	}
	return 0
}

func (x *ClusterStatus) GetNodesReady() int32 {
	if x != nil {
		return x.NodesReady
	}
	return 0
}

func (x *ClusterStatus) GetPodCapacity() int32 {
	if x != nil {
		return x.PodCapacity
	}
	return 0
}

func (x *ClusterStatus) GetPodCount() int32 {
	if x != nil {
		return x.PodCount
	}
	return 0
}

func (x *ClusterStatus) GetPodsRunning() int32 {
	if x != nil {
		return x.PodsRunning
	}
	return 0
}

func (x *ClusterStatus) GetPodsPending() int32 {
	if x != nil {
		return x.PodsPending
	}
	return 0
}

func (x *ClusterStatus) GetPodsFailed() int32 {
	if x != nil {
		return x.PodsFailed
	}
	return 0
}

func (x *ClusterStatus) GetCpuCapacityMillicores() int64 {
	if x != nil {
		return x.CpuCapacityMillicores
	}
	return 0
}

func (x *ClusterStatus) GetCpuUsedMillicores() int64 {
	if x != nil {
		return x.CpuUsedMillicores
	}
	return 0
}

func (x *ClusterStatus) GetMemoryCapacityBytes() int64 {
	if x != nil {
		return x.MemoryCapacityBytes
	}
	return 0
}

func (x *ClusterStatus) GetMemoryUsedBytes() int64 {
	if x != nil {
		return x.MemoryUsedBytes
	}
	return 0
}

func (x *ClusterStatus) GetWorkloadsTotal() int32 {
	if x != nil {
		return x.WorkloadsTotal
	}
	return 0
}

func (x *ClusterStatus) GetWorkloadsHealthy() int32 {
	if x != nil {
		return x.WorkloadsHealthy
	}
	return 0
}

func (x *ClusterStatus) GetWorkloadsDegraded() int32 {
	if x != nil {
		return x.WorkloadsDegraded
	}
	return 0
}

func (x *ClusterStatus) GetWorkloadsError() int32 {
	if x != nil {
		return x.WorkloadsError
	}
	return 0
}

// Workload represents a Kubernetes workload (Deployment, StatefulSet,
// DaemonSet, etc.) as observed by the agent.
type Workload struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Unique identifier for the workload within Admiral (UUID).
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// The cluster this workload belongs to (UUID).
	ClusterId string `protobuf:"bytes,2,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	// Kubernetes namespace.
	Namespace string `protobuf:"bytes,3,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// Workload name.
	Name string `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	// Kubernetes resource kind (e.g., "Deployment", "StatefulSet", "DaemonSet").
	Kind string `protobuf:"bytes,5,opt,name=kind,proto3" json:"kind,omitempty"`
	// Kubernetes labels on the workload.
	Labels map[string]string `protobuf:"bytes,6,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Derived health status.
	HealthStatus WorkloadHealthStatus `protobuf:"varint,7,opt,name=health_status,json=healthStatus,proto3,enum=admiral.api.cluster.v1.WorkloadHealthStatus" json:"health_status,omitempty"`
	// Human-readable reason for the current status (e.g., "MinimumReplicasUnavailable").
	StatusReason string `protobuf:"bytes,8,opt,name=status_reason,json=statusReason,proto3" json:"status_reason,omitempty"`
	// Number of desired replicas.
	ReplicasDesired int32 `protobuf:"varint,9,opt,name=replicas_desired,json=replicasDesired,proto3" json:"replicas_desired,omitempty"`
	// Number of ready replicas.
	ReplicasReady int32 `protobuf:"varint,10,opt,name=replicas_ready,json=replicasReady,proto3" json:"replicas_ready,omitempty"`
	// Number of available replicas.
	ReplicasAvailable int32 `protobuf:"varint,11,opt,name=replicas_available,json=replicasAvailable,proto3" json:"replicas_available,omitempty"`
	// CPU requests across all containers, in millicores.
	CpuRequestsMillicores int64 `protobuf:"varint,12,opt,name=cpu_requests_millicores,json=cpuRequestsMillicores,proto3" json:"cpu_requests_millicores,omitempty"`
	// CPU limits across all containers, in millicores.
	CpuLimitsMillicores int64 `protobuf:"varint,13,opt,name=cpu_limits_millicores,json=cpuLimitsMillicores,proto3" json:"cpu_limits_millicores,omitempty"`
	// Current CPU usage across all containers, in millicores.
	CpuUsedMillicores int64 `protobuf:"varint,14,opt,name=cpu_used_millicores,json=cpuUsedMillicores,proto3" json:"cpu_used_millicores,omitempty"`
	// Memory requests across all containers, in bytes.
	MemoryRequestsBytes int64 `protobuf:"varint,15,opt,name=memory_requests_bytes,json=memoryRequestsBytes,proto3" json:"memory_requests_bytes,omitempty"`
	// Memory limits across all containers, in bytes.
	MemoryLimitsBytes int64 `protobuf:"varint,16,opt,name=memory_limits_bytes,json=memoryLimitsBytes,proto3" json:"memory_limits_bytes,omitempty"`
	// Current memory usage across all containers, in bytes.
	MemoryUsedBytes int64 `protobuf:"varint,17,opt,name=memory_used_bytes,json=memoryUsedBytes,proto3" json:"memory_used_bytes,omitempty"`
	// Status of individual containers in this workload.
	Containers []*ContainerStatus `protobuf:"bytes,18,rep,name=containers,proto3" json:"containers,omitempty"`
	// When this workload's status was last updated.
	LastUpdatedAt *timestamppb.Timestamp `protobuf:"bytes,19,opt,name=last_updated_at,json=lastUpdatedAt,proto3" json:"last_updated_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Workload) Reset() {
	*x = Workload{}
	mi := &file_cluster_v1_cluster_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Workload) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Workload) ProtoMessage() {}

func (x *Workload) ProtoReflect() protoreflect.Message {
	mi := &file_cluster_v1_cluster_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Workload.ProtoReflect.Descriptor instead.
func (*Workload) Descriptor() ([]byte, []int) {
	return file_cluster_v1_cluster_proto_rawDescGZIP(), []int{2}
}

func (x *Workload) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *Workload) GetClusterId() string {
	if x != nil {
		return x.ClusterId
	}
	return ""
}

func (x *Workload) GetNamespace() string {
	if x != nil {
		return x.Namespace
	}
	return ""
}

func (x *Workload) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Workload) GetKind() string {
	if x != nil {
		return x.Kind
	}
	return ""
}

func (x *Workload) GetLabels() map[string]string {
	if x != nil {
		return x.Labels
	}
	return nil
}

func (x *Workload) GetHealthStatus() WorkloadHealthStatus {
	if x != nil {
		return x.HealthStatus
	}
	return WorkloadHealthStatus_WORKLOAD_HEALTH_STATUS_UNSPECIFIED
}

func (x *Workload) GetStatusReason() string {
	if x != nil {
		return x.StatusReason
	}
	return ""
}

func (x *Workload) GetReplicasDesired() int32 {
	if x != nil {
		return x.ReplicasDesired
	}
	return 0
}

func (x *Workload) GetReplicasReady() int32 {
	if x != nil {
		return x.ReplicasReady
	}
	return 0
}

func (x *Workload) GetReplicasAvailable() int32 {
	if x != nil {
		return x.ReplicasAvailable
	}
	return 0
}

func (x *Workload) GetCpuRequestsMillicores() int64 {
	if x != nil {
		return x.CpuRequestsMillicores
	}
	return 0
}

func (x *Workload) GetCpuLimitsMillicores() int64 {
	if x != nil {
		return x.CpuLimitsMillicores
	}
	return 0
}

func (x *Workload) GetCpuUsedMillicores() int64 {
	if x != nil {
		return x.CpuUsedMillicores
	}
	return 0
}

func (x *Workload) GetMemoryRequestsBytes() int64 {
	if x != nil {
		return x.MemoryRequestsBytes
	}
	return 0
}

func (x *Workload) GetMemoryLimitsBytes() int64 {
	if x != nil {
		return x.MemoryLimitsBytes
	}
	return 0
}

func (x *Workload) GetMemoryUsedBytes() int64 {
	if x != nil {
		return x.MemoryUsedBytes
	}
	return 0
}

func (x *Workload) GetContainers() []*ContainerStatus {
	if x != nil {
		return x.Containers
	}
	return nil
}

func (x *Workload) GetLastUpdatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.LastUpdatedAt
	}
	return nil
}

// ContainerStatus describes the current state of a single container.
type ContainerStatus struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Container name within the pod spec.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Container image reference (e.g., "registry.example.com/api:v2.1.4").
	Image string `protobuf:"bytes,2,opt,name=image,proto3" json:"image,omitempty"`
	// Cumulative number of container restarts.
	RestartCount int32 `protobuf:"varint,3,opt,name=restart_count,json=restartCount,proto3" json:"restart_count,omitempty"`
	// Current container state (e.g., "running", "waiting", "terminated").
	State string `protobuf:"bytes,4,opt,name=state,proto3" json:"state,omitempty"`
	// Whether the container's readiness probe is passing.
	Ready         bool `protobuf:"varint,5,opt,name=ready,proto3" json:"ready,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ContainerStatus) Reset() {
	*x = ContainerStatus{}
	mi := &file_cluster_v1_cluster_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ContainerStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ContainerStatus) ProtoMessage() {}

func (x *ContainerStatus) ProtoReflect() protoreflect.Message {
	mi := &file_cluster_v1_cluster_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ContainerStatus.ProtoReflect.Descriptor instead.
func (*ContainerStatus) Descriptor() ([]byte, []int) {
	return file_cluster_v1_cluster_proto_rawDescGZIP(), []int{3}
}

func (x *ContainerStatus) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ContainerStatus) GetImage() string {
	if x != nil {
		return x.Image
	}
	return ""
}

func (x *ContainerStatus) GetRestartCount() int32 {
	if x != nil {
		return x.RestartCount
	}
	return 0
}

func (x *ContainerStatus) GetState() string {
	if x != nil {
		return x.State
	}
	return ""
}

func (x *ContainerStatus) GetReady() bool {
	if x != nil {
		return x.Ready
	}
	return false
}

// ObjectReference is a lightweight reference to a Kubernetes object.
type ObjectReference struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Kubernetes resource kind (e.g., "Pod", "ReplicaSet").
	Kind string `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	// Kubernetes namespace.
	Namespace string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// Object name.
	Name          string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ObjectReference) Reset() {
	*x = ObjectReference{}
	mi := &file_cluster_v1_cluster_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ObjectReference) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ObjectReference) ProtoMessage() {}

func (x *ObjectReference) ProtoReflect() protoreflect.Message {
	mi := &file_cluster_v1_cluster_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ObjectReference.ProtoReflect.Descriptor instead.
func (*ObjectReference) Descriptor() ([]byte, []int) {
	return file_cluster_v1_cluster_proto_rawDescGZIP(), []int{4}
}

func (x *ObjectReference) GetKind() string {
	if x != nil {
		return x.Kind
	}
	return ""
}

func (x *ObjectReference) GetNamespace() string {
	if x != nil {
		return x.Namespace
	}
	return ""
}

func (x *ObjectReference) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

// WorkloadEvent represents a Kubernetes event related to a workload or its
// child objects (pods, replicasets). Events are deduplicated by their K8s UID.
type WorkloadEvent struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Kubernetes event UID, used for deduplication.
	Uid string `protobuf:"bytes,1,opt,name=uid,proto3" json:"uid,omitempty"`
	// Event type: "Normal" or "Warning".
	Type string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	// Short machine-readable reason (e.g., "BackOff", "FailedScheduling").
	Reason string `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
	// The Kubernetes object this event is about.
	Regarding *ObjectReference `protobuf:"bytes,4,opt,name=regarding,proto3" json:"regarding,omitempty"`
	// Human-readable event message.
	Message string `protobuf:"bytes,5,opt,name=message,proto3" json:"message,omitempty"`
	// When this event was first observed.
	FirstSeen *timestamppb.Timestamp `protobuf:"bytes,6,opt,name=first_seen,json=firstSeen,proto3" json:"first_seen,omitempty"`
	// When this event was most recently observed.
	LastSeen *timestamppb.Timestamp `protobuf:"bytes,7,opt,name=last_seen,json=lastSeen,proto3" json:"last_seen,omitempty"`
	// Number of times this event has occurred.
	Count         int32 `protobuf:"varint,8,opt,name=count,proto3" json:"count,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WorkloadEvent) Reset() {
	*x = WorkloadEvent{}
	mi := &file_cluster_v1_cluster_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WorkloadEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WorkloadEvent) ProtoMessage() {}

func (x *WorkloadEvent) ProtoReflect() protoreflect.Message {
	mi := &file_cluster_v1_cluster_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WorkloadEvent.ProtoReflect.Descriptor instead.
func (*WorkloadEvent) Descriptor() ([]byte, []int) {
	return file_cluster_v1_cluster_proto_rawDescGZIP(), []int{5}
}

func (x *WorkloadEvent) GetUid() string {
	if x != nil {
		return x.Uid
	}
	return ""
}

func (x *WorkloadEvent) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *WorkloadEvent) GetReason() string {
	if x != nil {
		return x.Reason
	}
	return ""
}

func (x *WorkloadEvent) GetRegarding() *ObjectReference {
	if x != nil {
		return x.Regarding
	}
	return nil
}

func (x *WorkloadEvent) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *WorkloadEvent) GetFirstSeen() *timestamppb.Timestamp {
	if x != nil {
		return x.FirstSeen
	}
	return nil
}

func (x *WorkloadEvent) GetLastSeen() *timestamppb.Timestamp {
	if x != nil {
		return x.LastSeen
	}
	return nil
}

func (x *WorkloadEvent) GetCount() int32 {
	if x != nil {
		return x.Count
	}
	return 0
}

// CreateClusterRequest contains the parameters for creating a new cluster.
type CreateClusterRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Human-readable name for the cluster (e.g., "prod-us-east-1").
	// Must be unique within the tenant.
	DisplayName string `protobuf:"bytes,1,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	// Arbitrary key-value labels for organizing and filtering clusters
	// (e.g., `{"region": "us-east-1", "cloud": "aws"}`).
	Labels        map[string]string `protobuf:"bytes,2,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateClusterRequest) Reset() {
	*x = CreateClusterRequest{}
	mi := &file_cluster_v1_cluster_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateClusterRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateClusterRequest) ProtoMessage() {}

func (x *CreateClusterRequest) ProtoReflect() protoreflect.Message {
	mi := &file_cluster_v1_cluster_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateClusterRequest.ProtoReflect.Descriptor instead.
func (*CreateClusterRequest) Descriptor() ([]byte, []int) {
	return file_cluster_v1_cluster_proto_rawDescGZIP(), []int{6}
}

func (x *CreateClusterRequest) GetDisplayName() string {
	if x != nil {
		return x.DisplayName
	}
	return ""
}

func (x *CreateClusterRequest) GetLabels() map[string]string {
	if x != nil {
		return x.Labels
	}
	return nil
}

// CreateClusterResponse contains the newly created cluster and its initial
// Agent Token (AGT).
type CreateClusterResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The created cluster. Health status will be PENDING until an agent connects
	// and calls AgentAPI.RegisterAgent.
	Cluster *Cluster `protobuf:"bytes,1,opt,name=cluster,proto3" json:"cluster,omitempty"`
	// The raw Agent Token secret (e.g., "adm_agt_pL2mN5oQ8rS1..."). This value
	// is shown exactly once and cannot be retrieved again. Deploy this token to
	// the K8s agent for authentication.
	//
	// To create additional tokens (e.g., for rotation), use
	// AccessTokenAPI.CreateAgentToken.
	PlainTextToken string `protobuf:"bytes,2,opt,name=plain_text_token,json=plainTextToken,proto3" json:"plain_text_token,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *CreateClusterResponse) Reset() {
	*x = CreateClusterResponse{}
	mi := &file_cluster_v1_cluster_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateClusterResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateClusterResponse) ProtoMessage() {}

func (x *CreateClusterResponse) ProtoReflect() protoreflect.Message {
	mi := &file_cluster_v1_cluster_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateClusterResponse.ProtoReflect.Descriptor instead.
func (*CreateClusterResponse) Descriptor() ([]byte, []int) {
	return file_cluster_v1_cluster_proto_rawDescGZIP(), []int{7}
}

func (x *CreateClusterResponse) GetCluster() *Cluster {
	if x != nil {
		return x.Cluster
	}
	return nil
}

func (x *CreateClusterResponse) GetPlainTextToken() string {
	if x != nil {
		return x.PlainTextToken
	}
	return ""
}

// GetClusterRequest identifies a cluster to retrieve.
type GetClusterRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The unique identifier of the cluster (UUID).
	ClusterId     string `protobuf:"bytes,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetClusterRequest) Reset() {
	*x = GetClusterRequest{}
	mi := &file_cluster_v1_cluster_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetClusterRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetClusterRequest) ProtoMessage() {}

func (x *GetClusterRequest) ProtoReflect() protoreflect.Message {
	mi := &file_cluster_v1_cluster_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetClusterRequest.ProtoReflect.Descriptor instead.
func (*GetClusterRequest) Descriptor() ([]byte, []int) {
	return file_cluster_v1_cluster_proto_rawDescGZIP(), []int{8}
}

func (x *GetClusterRequest) GetClusterId() string {
	if x != nil {
		return x.ClusterId
	}
	return ""
}

// GetClusterResponse contains the cluster record.
type GetClusterResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The cluster record, including server-derived health_status.
	Cluster       *Cluster `protobuf:"bytes,1,opt,name=cluster,proto3" json:"cluster,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetClusterResponse) Reset() {
	*x = GetClusterResponse{}
	mi := &file_cluster_v1_cluster_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetClusterResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetClusterResponse) ProtoMessage() {}

func (x *GetClusterResponse) ProtoReflect() protoreflect.Message {
	mi := &file_cluster_v1_cluster_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetClusterResponse.ProtoReflect.Descriptor instead.
func (*GetClusterResponse) Descriptor() ([]byte, []int) {
	return file_cluster_v1_cluster_proto_rawDescGZIP(), []int{9}
}

func (x *GetClusterResponse) GetCluster() *Cluster {
	if x != nil {
		return x.Cluster
	}
	return nil
}

// ListClustersRequest contains pagination and filter parameters.
type ListClustersRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Maximum number of clusters to return per page.
	PageSize int32 `protobuf:"varint,1,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	// Opaque pagination token from a previous response.
	PageToken string `protobuf:"bytes,2,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	// Filter expression using the PEG filter DSL
	// (e.g., `health_status = "healthy"` or `labels.region = "us-east-1"`).
	Filter        string `protobuf:"bytes,3,opt,name=filter,proto3" json:"filter,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListClustersRequest) Reset() {
	*x = ListClustersRequest{}
	mi := &file_cluster_v1_cluster_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListClustersRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListClustersRequest) ProtoMessage() {}

func (x *ListClustersRequest) ProtoReflect() protoreflect.Message {
	mi := &file_cluster_v1_cluster_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListClustersRequest.ProtoReflect.Descriptor instead.
func (*ListClustersRequest) Descriptor() ([]byte, []int) {
	return file_cluster_v1_cluster_proto_rawDescGZIP(), []int{10}
}

func (x *ListClustersRequest) GetPageSize() int32 {
	if x != nil {
		return x.PageSize
	}
	return 0
}

func (x *ListClustersRequest) GetPageToken() string {
	if x != nil {
		return x.PageToken
	}
	return ""
}

func (x *ListClustersRequest) GetFilter() string {
	if x != nil {
		return x.Filter
	}
	return ""
}

// ListClustersResponse contains a page of clusters.
type ListClustersResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The list of clusters.
	Clusters []*Cluster `protobuf:"bytes,1,rep,name=clusters,proto3" json:"clusters,omitempty"`
	// Pagination token for the next page. Empty when there are no more results.
	NextPageToken string `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListClustersResponse) Reset() {
	*x = ListClustersResponse{}
	mi := &file_cluster_v1_cluster_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListClustersResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListClustersResponse) ProtoMessage() {}

func (x *ListClustersResponse) ProtoReflect() protoreflect.Message {
	mi := &file_cluster_v1_cluster_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListClustersResponse.ProtoReflect.Descriptor instead.
func (*ListClustersResponse) Descriptor() ([]byte, []int) {
	return file_cluster_v1_cluster_proto_rawDescGZIP(), []int{11}
}

func (x *ListClustersResponse) GetClusters() []*Cluster {
	if x != nil {
		return x.Clusters
	}
	return nil
}

func (x *ListClustersResponse) GetNextPageToken() string {
	if x != nil {
		return x.NextPageToken
	}
	return ""
}

// UpdateClusterRequest contains the cluster fields to update.
type UpdateClusterRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The cluster with updated fields. The `id` field is required.
	// Only fields specified in `update_mask` are updated.
	Cluster *Cluster `protobuf:"bytes,1,opt,name=cluster,proto3" json:"cluster,omitempty"`
	// The set of fields to update. If unset, all mutable fields are updated.
	// Supported fields: `display_name`, `labels`.
	UpdateMask    *fieldmaskpb.FieldMask `protobuf:"bytes,2,opt,name=update_mask,json=updateMask,proto3" json:"update_mask,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateClusterRequest) Reset() {
	*x = UpdateClusterRequest{}
	mi := &file_cluster_v1_cluster_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateClusterRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateClusterRequest) ProtoMessage() {}

func (x *UpdateClusterRequest) ProtoReflect() protoreflect.Message {
	mi := &file_cluster_v1_cluster_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateClusterRequest.ProtoReflect.Descriptor instead.
func (*UpdateClusterRequest) Descriptor() ([]byte, []int) {
	return file_cluster_v1_cluster_proto_rawDescGZIP(), []int{12}
}

func (x *UpdateClusterRequest) GetCluster() *Cluster {
	if x != nil {
		return x.Cluster
	}
	return nil
}

func (x *UpdateClusterRequest) GetUpdateMask() *fieldmaskpb.FieldMask {
	if x != nil {
		return x.UpdateMask
	}
	return nil
}

// UpdateClusterResponse contains the updated cluster.
type UpdateClusterResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The updated cluster.
	Cluster       *Cluster `protobuf:"bytes,1,opt,name=cluster,proto3" json:"cluster,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateClusterResponse) Reset() {
	*x = UpdateClusterResponse{}
	mi := &file_cluster_v1_cluster_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateClusterResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateClusterResponse) ProtoMessage() {}

func (x *UpdateClusterResponse) ProtoReflect() protoreflect.Message {
	mi := &file_cluster_v1_cluster_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateClusterResponse.ProtoReflect.Descriptor instead.
func (*UpdateClusterResponse) Descriptor() ([]byte, []int) {
	return file_cluster_v1_cluster_proto_rawDescGZIP(), []int{13}
}

func (x *UpdateClusterResponse) GetCluster() *Cluster {
	if x != nil {
		return x.Cluster
	}
	return nil
}

// DeleteClusterRequest identifies a cluster to delete.
type DeleteClusterRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The unique identifier of the cluster to delete (UUID).
	// All associated agent tokens will be revoked.
	ClusterId     string `protobuf:"bytes,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteClusterRequest) Reset() {
	*x = DeleteClusterRequest{}
	mi := &file_cluster_v1_cluster_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteClusterRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteClusterRequest) ProtoMessage() {}

func (x *DeleteClusterRequest) ProtoReflect() protoreflect.Message {
	mi := &file_cluster_v1_cluster_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteClusterRequest.ProtoReflect.Descriptor instead.
func (*DeleteClusterRequest) Descriptor() ([]byte, []int) {
	return file_cluster_v1_cluster_proto_rawDescGZIP(), []int{14}
}

func (x *DeleteClusterRequest) GetClusterId() string {
	if x != nil {
		return x.ClusterId
	}
	return ""
}

// DeleteClusterResponse is empty on success.
type DeleteClusterResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteClusterResponse) Reset() {
	*x = DeleteClusterResponse{}
	mi := &file_cluster_v1_cluster_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteClusterResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteClusterResponse) ProtoMessage() {}

func (x *DeleteClusterResponse) ProtoReflect() protoreflect.Message {
	mi := &file_cluster_v1_cluster_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteClusterResponse.ProtoReflect.Descriptor instead.
func (*DeleteClusterResponse) Descriptor() ([]byte, []int) {
	return file_cluster_v1_cluster_proto_rawDescGZIP(), []int{15}
}

// GetClusterStatusRequest identifies a cluster whose telemetry status to retrieve.
type GetClusterStatusRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The unique identifier of the cluster (UUID).
	ClusterId     string `protobuf:"bytes,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetClusterStatusRequest) Reset() {
	*x = GetClusterStatusRequest{}
	mi := &file_cluster_v1_cluster_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetClusterStatusRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetClusterStatusRequest) ProtoMessage() {}

func (x *GetClusterStatusRequest) ProtoReflect() protoreflect.Message {
	mi := &file_cluster_v1_cluster_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetClusterStatusRequest.ProtoReflect.Descriptor instead.
func (*GetClusterStatusRequest) Descriptor() ([]byte, []int) {
	return file_cluster_v1_cluster_proto_rawDescGZIP(), []int{16}
}

func (x *GetClusterStatusRequest) GetClusterId() string {
	if x != nil {
		return x.ClusterId
	}
	return ""
}

// GetClusterStatusResponse contains the server-derived health status and the
// latest telemetry snapshot. If no agent has reported telemetry yet, the
// health_status will be PENDING and status will be absent.
type GetClusterStatusResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Server-derived health status based on agent connectivity, node readiness,
	// and workload health.
	HealthStatus ClusterHealthStatus `protobuf:"varint,1,opt,name=health_status,json=healthStatus,proto3,enum=admiral.api.cluster.v1.ClusterHealthStatus" json:"health_status,omitempty"`
	// Latest telemetry snapshot from the agent. Absent if no telemetry has
	// been reported yet.
	Status *ClusterStatus `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	// When the latest telemetry was reported by the agent.
	ReportedAt    *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=reported_at,json=reportedAt,proto3" json:"reported_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetClusterStatusResponse) Reset() {
	*x = GetClusterStatusResponse{}
	mi := &file_cluster_v1_cluster_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetClusterStatusResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetClusterStatusResponse) ProtoMessage() {}

func (x *GetClusterStatusResponse) ProtoReflect() protoreflect.Message {
	mi := &file_cluster_v1_cluster_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetClusterStatusResponse.ProtoReflect.Descriptor instead.
func (*GetClusterStatusResponse) Descriptor() ([]byte, []int) {
	return file_cluster_v1_cluster_proto_rawDescGZIP(), []int{17}
}

func (x *GetClusterStatusResponse) GetHealthStatus() ClusterHealthStatus {
	if x != nil {
		return x.HealthStatus
	}
	return ClusterHealthStatus_CLUSTER_HEALTH_STATUS_UNSPECIFIED
}

func (x *GetClusterStatusResponse) GetStatus() *ClusterStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

func (x *GetClusterStatusResponse) GetReportedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.ReportedAt
	}
	return nil
}

// ReportClusterStatusRequest contains a combined telemetry payload from a K8s agent.
// Admiral splits this into three storage tiers: current snapshot, time-series
// metrics, and events.
type ReportClusterStatusRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The cluster this status report is for (UUID).
	ClusterId string `protobuf:"bytes,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	// Cluster-level telemetry snapshot.
	Status *ClusterStatus `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	// Per-workload status snapshots.
	Workloads []*WorkloadStatus `protobuf:"bytes,3,rep,name=workloads,proto3" json:"workloads,omitempty"`
	// Kubernetes events observed since the last push.
	Events []*WorkloadEvent `protobuf:"bytes,4,rep,name=events,proto3" json:"events,omitempty"`
	// When the agent generated this report.
	ReportedAt    *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=reported_at,json=reportedAt,proto3" json:"reported_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReportClusterStatusRequest) Reset() {
	*x = ReportClusterStatusRequest{}
	mi := &file_cluster_v1_cluster_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReportClusterStatusRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReportClusterStatusRequest) ProtoMessage() {}

func (x *ReportClusterStatusRequest) ProtoReflect() protoreflect.Message {
	mi := &file_cluster_v1_cluster_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReportClusterStatusRequest.ProtoReflect.Descriptor instead.
func (*ReportClusterStatusRequest) Descriptor() ([]byte, []int) {
	return file_cluster_v1_cluster_proto_rawDescGZIP(), []int{18}
}

func (x *ReportClusterStatusRequest) GetClusterId() string {
	if x != nil {
		return x.ClusterId
	}
	return ""
}

func (x *ReportClusterStatusRequest) GetStatus() *ClusterStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

func (x *ReportClusterStatusRequest) GetWorkloads() []*WorkloadStatus {
	if x != nil {
		return x.Workloads
	}
	return nil
}

func (x *ReportClusterStatusRequest) GetEvents() []*WorkloadEvent {
	if x != nil {
		return x.Events
	}
	return nil
}

func (x *ReportClusterStatusRequest) GetReportedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.ReportedAt
	}
	return nil
}

// WorkloadStatus is the agent-reported status for a single workload within
// a telemetry push payload.
type WorkloadStatus struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Kubernetes namespace.
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// Workload name.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Kubernetes resource kind (e.g., "Deployment", "StatefulSet").
	Kind string `protobuf:"bytes,3,opt,name=kind,proto3" json:"kind,omitempty"`
	// Kubernetes labels on the workload.
	Labels map[string]string `protobuf:"bytes,4,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Number of desired replicas.
	ReplicasDesired int32 `protobuf:"varint,5,opt,name=replicas_desired,json=replicasDesired,proto3" json:"replicas_desired,omitempty"`
	// Number of ready replicas.
	ReplicasReady int32 `protobuf:"varint,6,opt,name=replicas_ready,json=replicasReady,proto3" json:"replicas_ready,omitempty"`
	// Number of available replicas.
	ReplicasAvailable int32 `protobuf:"varint,7,opt,name=replicas_available,json=replicasAvailable,proto3" json:"replicas_available,omitempty"`
	// CPU requests across all containers, in millicores.
	CpuRequestsMillicores int64 `protobuf:"varint,8,opt,name=cpu_requests_millicores,json=cpuRequestsMillicores,proto3" json:"cpu_requests_millicores,omitempty"`
	// CPU limits across all containers, in millicores.
	CpuLimitsMillicores int64 `protobuf:"varint,9,opt,name=cpu_limits_millicores,json=cpuLimitsMillicores,proto3" json:"cpu_limits_millicores,omitempty"`
	// Current CPU usage across all containers, in millicores.
	CpuUsedMillicores int64 `protobuf:"varint,10,opt,name=cpu_used_millicores,json=cpuUsedMillicores,proto3" json:"cpu_used_millicores,omitempty"`
	// Memory requests across all containers, in bytes.
	MemoryRequestsBytes int64 `protobuf:"varint,11,opt,name=memory_requests_bytes,json=memoryRequestsBytes,proto3" json:"memory_requests_bytes,omitempty"`
	// Memory limits across all containers, in bytes.
	MemoryLimitsBytes int64 `protobuf:"varint,12,opt,name=memory_limits_bytes,json=memoryLimitsBytes,proto3" json:"memory_limits_bytes,omitempty"`
	// Current memory usage across all containers, in bytes.
	MemoryUsedBytes int64 `protobuf:"varint,13,opt,name=memory_used_bytes,json=memoryUsedBytes,proto3" json:"memory_used_bytes,omitempty"`
	// Derived health status.
	HealthStatus WorkloadHealthStatus `protobuf:"varint,14,opt,name=health_status,json=healthStatus,proto3,enum=admiral.api.cluster.v1.WorkloadHealthStatus" json:"health_status,omitempty"`
	// Status of individual containers.
	Containers    []*ContainerStatus `protobuf:"bytes,15,rep,name=containers,proto3" json:"containers,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WorkloadStatus) Reset() {
	*x = WorkloadStatus{}
	mi := &file_cluster_v1_cluster_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WorkloadStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WorkloadStatus) ProtoMessage() {}

func (x *WorkloadStatus) ProtoReflect() protoreflect.Message {
	mi := &file_cluster_v1_cluster_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WorkloadStatus.ProtoReflect.Descriptor instead.
func (*WorkloadStatus) Descriptor() ([]byte, []int) {
	return file_cluster_v1_cluster_proto_rawDescGZIP(), []int{19}
}

func (x *WorkloadStatus) GetNamespace() string {
	if x != nil {
		return x.Namespace
	}
	return ""
}

func (x *WorkloadStatus) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *WorkloadStatus) GetKind() string {
	if x != nil {
		return x.Kind
	}
	return ""
}

func (x *WorkloadStatus) GetLabels() map[string]string {
	if x != nil {
		return x.Labels
	}
	return nil
}

func (x *WorkloadStatus) GetReplicasDesired() int32 {
	if x != nil {
		return x.ReplicasDesired
	}
	return 0
}

func (x *WorkloadStatus) GetReplicasReady() int32 {
	if x != nil {
		return x.ReplicasReady
	}
	return 0
}

func (x *WorkloadStatus) GetReplicasAvailable() int32 {
	if x != nil {
		return x.ReplicasAvailable
	}
	return 0
}

func (x *WorkloadStatus) GetCpuRequestsMillicores() int64 {
	if x != nil {
		return x.CpuRequestsMillicores
	}
	return 0
}

func (x *WorkloadStatus) GetCpuLimitsMillicores() int64 {
	if x != nil {
		return x.CpuLimitsMillicores
	}
	return 0
}

func (x *WorkloadStatus) GetCpuUsedMillicores() int64 {
	if x != nil {
		return x.CpuUsedMillicores
	}
	return 0
}

func (x *WorkloadStatus) GetMemoryRequestsBytes() int64 {
	if x != nil {
		return x.MemoryRequestsBytes
	}
	return 0
}

func (x *WorkloadStatus) GetMemoryLimitsBytes() int64 {
	if x != nil {
		return x.MemoryLimitsBytes
	}
	return 0
}

func (x *WorkloadStatus) GetMemoryUsedBytes() int64 {
	if x != nil {
		return x.MemoryUsedBytes
	}
	return 0
}

func (x *WorkloadStatus) GetHealthStatus() WorkloadHealthStatus {
	if x != nil {
		return x.HealthStatus
	}
	return WorkloadHealthStatus_WORKLOAD_HEALTH_STATUS_UNSPECIFIED
}

func (x *WorkloadStatus) GetContainers() []*ContainerStatus {
	if x != nil {
		return x.Containers
	}
	return nil
}

// ReportClusterStatusResponse acknowledges a telemetry push.
type ReportClusterStatusResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Whether the report was accepted.
	Ack bool `protobuf:"varint,1,opt,name=ack,proto3" json:"ack,omitempty"`
	// Server-controlled interval (in seconds) before the agent should send
	// its next status push. Allows the server to adjust push frequency dynamically.
	NextPushSeconds int32 `protobuf:"varint,2,opt,name=next_push_seconds,json=nextPushSeconds,proto3" json:"next_push_seconds,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *ReportClusterStatusResponse) Reset() {
	*x = ReportClusterStatusResponse{}
	mi := &file_cluster_v1_cluster_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReportClusterStatusResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReportClusterStatusResponse) ProtoMessage() {}

func (x *ReportClusterStatusResponse) ProtoReflect() protoreflect.Message {
	mi := &file_cluster_v1_cluster_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReportClusterStatusResponse.ProtoReflect.Descriptor instead.
func (*ReportClusterStatusResponse) Descriptor() ([]byte, []int) {
	return file_cluster_v1_cluster_proto_rawDescGZIP(), []int{20}
}

func (x *ReportClusterStatusResponse) GetAck() bool {
	if x != nil {
		return x.Ack
	}
	return false
}

func (x *ReportClusterStatusResponse) GetNextPushSeconds() int32 {
	if x != nil {
		return x.NextPushSeconds
	}
	return 0
}

// ListWorkloadsRequest contains pagination and filter parameters for listing
// workloads in a specific cluster.
type ListWorkloadsRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The cluster whose workloads to list (UUID).
	ClusterId string `protobuf:"bytes,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	// Maximum number of workloads to return per page.
	PageSize int32 `protobuf:"varint,2,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	// Opaque pagination token from a previous response.
	PageToken string `protobuf:"bytes,3,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	// Filter expression using the PEG filter DSL
	// (e.g., `namespace = "production"` or `health_status = "degraded"`).
	Filter        string `protobuf:"bytes,4,opt,name=filter,proto3" json:"filter,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListWorkloadsRequest) Reset() {
	*x = ListWorkloadsRequest{}
	mi := &file_cluster_v1_cluster_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListWorkloadsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListWorkloadsRequest) ProtoMessage() {}

func (x *ListWorkloadsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_cluster_v1_cluster_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListWorkloadsRequest.ProtoReflect.Descriptor instead.
func (*ListWorkloadsRequest) Descriptor() ([]byte, []int) {
	return file_cluster_v1_cluster_proto_rawDescGZIP(), []int{21}
}

func (x *ListWorkloadsRequest) GetClusterId() string {
	if x != nil {
		return x.ClusterId
	}
	return ""
}

func (x *ListWorkloadsRequest) GetPageSize() int32 {
	if x != nil {
		return x.PageSize
	}
	return 0
}

func (x *ListWorkloadsRequest) GetPageToken() string {
	if x != nil {
		return x.PageToken
	}
	return ""
}

func (x *ListWorkloadsRequest) GetFilter() string {
	if x != nil {
		return x.Filter
	}
	return ""
}

// ListWorkloadsResponse contains a page of workloads.
type ListWorkloadsResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The list of workloads.
	Workloads []*Workload `protobuf:"bytes,1,rep,name=workloads,proto3" json:"workloads,omitempty"`
	// Pagination token for the next page. Empty when there are no more results.
	NextPageToken string `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListWorkloadsResponse) Reset() {
	*x = ListWorkloadsResponse{}
	mi := &file_cluster_v1_cluster_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListWorkloadsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListWorkloadsResponse) ProtoMessage() {}

func (x *ListWorkloadsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_cluster_v1_cluster_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListWorkloadsResponse.ProtoReflect.Descriptor instead.
func (*ListWorkloadsResponse) Descriptor() ([]byte, []int) {
	return file_cluster_v1_cluster_proto_rawDescGZIP(), []int{22}
}

func (x *ListWorkloadsResponse) GetWorkloads() []*Workload {
	if x != nil {
		return x.Workloads
	}
	return nil
}

func (x *ListWorkloadsResponse) GetNextPageToken() string {
	if x != nil {
		return x.NextPageToken
	}
	return ""
}

// ReportWorkloadStatusRequest contains incremental workload telemetry from a K8s agent.
type ReportWorkloadStatusRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The cluster these workloads belong to (UUID).
	ClusterId string `protobuf:"bytes,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	// Per-workload status snapshots.
	Workloads []*WorkloadStatus `protobuf:"bytes,2,rep,name=workloads,proto3" json:"workloads,omitempty"`
	// When the agent generated this report.
	ReportedAt    *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=reported_at,json=reportedAt,proto3" json:"reported_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReportWorkloadStatusRequest) Reset() {
	*x = ReportWorkloadStatusRequest{}
	mi := &file_cluster_v1_cluster_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReportWorkloadStatusRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReportWorkloadStatusRequest) ProtoMessage() {}

func (x *ReportWorkloadStatusRequest) ProtoReflect() protoreflect.Message {
	mi := &file_cluster_v1_cluster_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReportWorkloadStatusRequest.ProtoReflect.Descriptor instead.
func (*ReportWorkloadStatusRequest) Descriptor() ([]byte, []int) {
	return file_cluster_v1_cluster_proto_rawDescGZIP(), []int{23}
}

func (x *ReportWorkloadStatusRequest) GetClusterId() string {
	if x != nil {
		return x.ClusterId
	}
	return ""
}

func (x *ReportWorkloadStatusRequest) GetWorkloads() []*WorkloadStatus {
	if x != nil {
		return x.Workloads
	}
	return nil
}

func (x *ReportWorkloadStatusRequest) GetReportedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.ReportedAt
	}
	return nil
}

// ReportWorkloadStatusResponse acknowledges a workload telemetry push.
type ReportWorkloadStatusResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Whether the report was accepted.
	Ack           bool `protobuf:"varint,1,opt,name=ack,proto3" json:"ack,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReportWorkloadStatusResponse) Reset() {
	*x = ReportWorkloadStatusResponse{}
	mi := &file_cluster_v1_cluster_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReportWorkloadStatusResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReportWorkloadStatusResponse) ProtoMessage() {}

func (x *ReportWorkloadStatusResponse) ProtoReflect() protoreflect.Message {
	mi := &file_cluster_v1_cluster_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReportWorkloadStatusResponse.ProtoReflect.Descriptor instead.
func (*ReportWorkloadStatusResponse) Descriptor() ([]byte, []int) {
	return file_cluster_v1_cluster_proto_rawDescGZIP(), []int{24}
}

func (x *ReportWorkloadStatusResponse) GetAck() bool {
	if x != nil {
		return x.Ack
	}
	return false
}

// CreateClusterTokenRequest contains the parameters for creating a new AGT
// bound to a cluster.
type CreateClusterTokenRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The cluster to bind this token to (UUID).
	ClusterId string `protobuf:"bytes,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	// Human-readable name for the token (e.g., "prod-us-east-1-agent-key").
	DisplayName string `protobuf:"bytes,2,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	// Optional expiration time. If unset, the token does not expire.
	ExpiresAt     *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateClusterTokenRequest) Reset() {
	*x = CreateClusterTokenRequest{}
	mi := &file_cluster_v1_cluster_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateClusterTokenRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateClusterTokenRequest) ProtoMessage() {}

func (x *CreateClusterTokenRequest) ProtoReflect() protoreflect.Message {
	mi := &file_cluster_v1_cluster_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateClusterTokenRequest.ProtoReflect.Descriptor instead.
func (*CreateClusterTokenRequest) Descriptor() ([]byte, []int) {
	return file_cluster_v1_cluster_proto_rawDescGZIP(), []int{25}
}

func (x *CreateClusterTokenRequest) GetClusterId() string {
	if x != nil {
		return x.ClusterId
	}
	return ""
}

func (x *CreateClusterTokenRequest) GetDisplayName() string {
	if x != nil {
		return x.DisplayName
	}
	return ""
}

func (x *CreateClusterTokenRequest) GetExpiresAt() *timestamppb.Timestamp {
	if x != nil {
		return x.ExpiresAt
	}
	return nil
}

// CreateClusterTokenResponse contains the newly created AGT.
type CreateClusterTokenResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The created token metadata. Scopes are auto-assigned for cluster AGTs.
	AccessToken *v1.AccessToken `protobuf:"bytes,1,opt,name=access_token,json=accessToken,proto3" json:"access_token,omitempty"`
	// The raw token secret (e.g., "adm_agt_pL2mN5oQ8rS1..."). This value is
	// shown exactly once and cannot be retrieved again. Store it securely.
	PlainTextToken string `protobuf:"bytes,2,opt,name=plain_text_token,json=plainTextToken,proto3" json:"plain_text_token,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *CreateClusterTokenResponse) Reset() {
	*x = CreateClusterTokenResponse{}
	mi := &file_cluster_v1_cluster_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateClusterTokenResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateClusterTokenResponse) ProtoMessage() {}

func (x *CreateClusterTokenResponse) ProtoReflect() protoreflect.Message {
	mi := &file_cluster_v1_cluster_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateClusterTokenResponse.ProtoReflect.Descriptor instead.
func (*CreateClusterTokenResponse) Descriptor() ([]byte, []int) {
	return file_cluster_v1_cluster_proto_rawDescGZIP(), []int{26}
}

func (x *CreateClusterTokenResponse) GetAccessToken() *v1.AccessToken {
	if x != nil {
		return x.AccessToken
	}
	return nil
}

func (x *CreateClusterTokenResponse) GetPlainTextToken() string {
	if x != nil {
		return x.PlainTextToken
	}
	return ""
}

// ListClusterTokensRequest contains pagination and filter parameters.
type ListClusterTokensRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The cluster whose tokens to list (UUID).
	ClusterId string `protobuf:"bytes,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	// Maximum number of tokens to return per page.
	PageSize int32 `protobuf:"varint,2,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	// Opaque pagination token from a previous response.
	PageToken string `protobuf:"bytes,3,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	// Filter expression using the PEG filter DSL.
	Filter        string `protobuf:"bytes,4,opt,name=filter,proto3" json:"filter,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListClusterTokensRequest) Reset() {
	*x = ListClusterTokensRequest{}
	mi := &file_cluster_v1_cluster_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListClusterTokensRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListClusterTokensRequest) ProtoMessage() {}

func (x *ListClusterTokensRequest) ProtoReflect() protoreflect.Message {
	mi := &file_cluster_v1_cluster_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListClusterTokensRequest.ProtoReflect.Descriptor instead.
func (*ListClusterTokensRequest) Descriptor() ([]byte, []int) {
	return file_cluster_v1_cluster_proto_rawDescGZIP(), []int{27}
}

func (x *ListClusterTokensRequest) GetClusterId() string {
	if x != nil {
		return x.ClusterId
	}
	return ""
}

func (x *ListClusterTokensRequest) GetPageSize() int32 {
	if x != nil {
		return x.PageSize
	}
	return 0
}

func (x *ListClusterTokensRequest) GetPageToken() string {
	if x != nil {
		return x.PageToken
	}
	return ""
}

func (x *ListClusterTokensRequest) GetFilter() string {
	if x != nil {
		return x.Filter
	}
	return ""
}

// ListClusterTokensResponse contains a page of cluster AGT metadata.
type ListClusterTokensResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The list of tokens. Token secrets are never included.
	AccessTokens []*v1.AccessToken `protobuf:"bytes,1,rep,name=access_tokens,json=accessTokens,proto3" json:"access_tokens,omitempty"`
	// Pagination token for the next page. Empty when there are no more results.
	NextPageToken string `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListClusterTokensResponse) Reset() {
	*x = ListClusterTokensResponse{}
	mi := &file_cluster_v1_cluster_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListClusterTokensResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListClusterTokensResponse) ProtoMessage() {}

func (x *ListClusterTokensResponse) ProtoReflect() protoreflect.Message {
	mi := &file_cluster_v1_cluster_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListClusterTokensResponse.ProtoReflect.Descriptor instead.
func (*ListClusterTokensResponse) Descriptor() ([]byte, []int) {
	return file_cluster_v1_cluster_proto_rawDescGZIP(), []int{28}
}

func (x *ListClusterTokensResponse) GetAccessTokens() []*v1.AccessToken {
	if x != nil {
		return x.AccessTokens
	}
	return nil
}

func (x *ListClusterTokensResponse) GetNextPageToken() string {
	if x != nil {
		return x.NextPageToken
	}
	return ""
}

// GetClusterTokenRequest identifies a cluster AGT to retrieve.
type GetClusterTokenRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The cluster the token belongs to (UUID).
	ClusterId string `protobuf:"bytes,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	// The unique identifier of the token (UUID).
	TokenId       string `protobuf:"bytes,2,opt,name=token_id,json=tokenId,proto3" json:"token_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetClusterTokenRequest) Reset() {
	*x = GetClusterTokenRequest{}
	mi := &file_cluster_v1_cluster_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetClusterTokenRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetClusterTokenRequest) ProtoMessage() {}

func (x *GetClusterTokenRequest) ProtoReflect() protoreflect.Message {
	mi := &file_cluster_v1_cluster_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetClusterTokenRequest.ProtoReflect.Descriptor instead.
func (*GetClusterTokenRequest) Descriptor() ([]byte, []int) {
	return file_cluster_v1_cluster_proto_rawDescGZIP(), []int{29}
}

func (x *GetClusterTokenRequest) GetClusterId() string {
	if x != nil {
		return x.ClusterId
	}
	return ""
}

func (x *GetClusterTokenRequest) GetTokenId() string {
	if x != nil {
		return x.TokenId
	}
	return ""
}

// GetClusterTokenResponse contains the requested cluster AGT metadata.
type GetClusterTokenResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The token metadata. The token secret is never included.
	AccessToken   *v1.AccessToken `protobuf:"bytes,1,opt,name=access_token,json=accessToken,proto3" json:"access_token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetClusterTokenResponse) Reset() {
	*x = GetClusterTokenResponse{}
	mi := &file_cluster_v1_cluster_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetClusterTokenResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetClusterTokenResponse) ProtoMessage() {}

func (x *GetClusterTokenResponse) ProtoReflect() protoreflect.Message {
	mi := &file_cluster_v1_cluster_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetClusterTokenResponse.ProtoReflect.Descriptor instead.
func (*GetClusterTokenResponse) Descriptor() ([]byte, []int) {
	return file_cluster_v1_cluster_proto_rawDescGZIP(), []int{30}
}

func (x *GetClusterTokenResponse) GetAccessToken() *v1.AccessToken {
	if x != nil {
		return x.AccessToken
	}
	return nil
}

// RevokeClusterTokenRequest identifies a cluster AGT to revoke.
type RevokeClusterTokenRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The cluster the token belongs to (UUID).
	ClusterId string `protobuf:"bytes,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	// The unique identifier of the token to revoke (UUID).
	TokenId       string `protobuf:"bytes,2,opt,name=token_id,json=tokenId,proto3" json:"token_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RevokeClusterTokenRequest) Reset() {
	*x = RevokeClusterTokenRequest{}
	mi := &file_cluster_v1_cluster_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RevokeClusterTokenRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RevokeClusterTokenRequest) ProtoMessage() {}

func (x *RevokeClusterTokenRequest) ProtoReflect() protoreflect.Message {
	mi := &file_cluster_v1_cluster_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RevokeClusterTokenRequest.ProtoReflect.Descriptor instead.
func (*RevokeClusterTokenRequest) Descriptor() ([]byte, []int) {
	return file_cluster_v1_cluster_proto_rawDescGZIP(), []int{31}
}

func (x *RevokeClusterTokenRequest) GetClusterId() string {
	if x != nil {
		return x.ClusterId
	}
	return ""
}

func (x *RevokeClusterTokenRequest) GetTokenId() string {
	if x != nil {
		return x.TokenId
	}
	return ""
}

// RevokeClusterTokenResponse contains the revoked cluster AGT metadata.
type RevokeClusterTokenResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The token metadata with updated status.
	AccessToken   *v1.AccessToken `protobuf:"bytes,1,opt,name=access_token,json=accessToken,proto3" json:"access_token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RevokeClusterTokenResponse) Reset() {
	*x = RevokeClusterTokenResponse{}
	mi := &file_cluster_v1_cluster_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RevokeClusterTokenResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RevokeClusterTokenResponse) ProtoMessage() {}

func (x *RevokeClusterTokenResponse) ProtoReflect() protoreflect.Message {
	mi := &file_cluster_v1_cluster_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RevokeClusterTokenResponse.ProtoReflect.Descriptor instead.
func (*RevokeClusterTokenResponse) Descriptor() ([]byte, []int) {
	return file_cluster_v1_cluster_proto_rawDescGZIP(), []int{32}
}

func (x *RevokeClusterTokenResponse) GetAccessToken() *v1.AccessToken {
	if x != nil {
		return x.AccessToken
	}
	return nil
}

var File_cluster_v1_cluster_proto protoreflect.FileDescriptor

const file_cluster_v1_cluster_proto_rawDesc = "" +
	"\n" +
	"\x18cluster/v1/cluster.proto\x12\x16admiral.api.cluster.v1\x1a accesstoken/v1/accesstoken.proto\x1a\x1aauthz/v1/annotations.proto\x1a\x1bbuf/validate/validate.proto\x1a\x1cgoogle/api/annotations.proto\x1a google/protobuf/field_mask.proto\x1a\x1fgoogle/protobuf/timestamp.proto\"\xe2\x03\n" +
	"\aCluster\x12\x18\n" +
	"\x02id\x18\x01 \x01(\tB\b\xbaH\x05r\x03\xb0\x01\x01R\x02id\x12%\n" +
	"\ttenant_id\x18\x02 \x01(\tB\b\xbaH\x05r\x03\xb0\x01\x01R\btenantId\x12-\n" +
	"\fdisplay_name\x18\x03 \x01(\tB\n" +
	"\xbaH\ar\x05\x10\x01\x18\xff\x01R\vdisplayName\x12C\n" +
	"\x06labels\x18\x04 \x03(\v2+.admiral.api.cluster.v1.Cluster.LabelsEntryR\x06labels\x12\x1f\n" +
	"\vcluster_uid\x18\x05 \x01(\tR\n" +
	"clusterUid\x12P\n" +
	"\rhealth_status\x18\x06 \x01(\x0e2+.admiral.api.cluster.v1.ClusterHealthStatusR\fhealthStatus\x129\n" +
	"\n" +
	"created_at\x18\a \x01(\v2\x1a.google.protobuf.TimestampR\tcreatedAt\x129\n" +
	"\n" +
	"updated_at\x18\b \x01(\v2\x1a.google.protobuf.TimestampR\tupdatedAt\x1a9\n" +
	"\vLabelsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\x8d\x05\n" +
	"\rClusterStatus\x12\x1f\n" +
	"\vk8s_version\x18\x01 \x01(\tR\n" +
	"k8sVersion\x12\x1d\n" +
	"\n" +
	"node_count\x18\x02 \x01(\x05R\tnodeCount\x12\x1f\n" +
	"\vnodes_ready\x18\x03 \x01(\x05R\n" +
	"nodesReady\x12!\n" +
	"\fpod_capacity\x18\x04 \x01(\x05R\vpodCapacity\x12\x1b\n" +
	"\tpod_count\x18\x05 \x01(\x05R\bpodCount\x12!\n" +
	"\fpods_running\x18\x06 \x01(\x05R\vpodsRunning\x12!\n" +
	"\fpods_pending\x18\a \x01(\x05R\vpodsPending\x12\x1f\n" +
	"\vpods_failed\x18\b \x01(\x05R\n" +
	"podsFailed\x126\n" +
	"\x17cpu_capacity_millicores\x18\t \x01(\x03R\x15cpuCapacityMillicores\x12.\n" +
	"\x13cpu_used_millicores\x18\n" +
	" \x01(\x03R\x11cpuUsedMillicores\x122\n" +
	"\x15memory_capacity_bytes\x18\v \x01(\x03R\x13memoryCapacityBytes\x12*\n" +
	"\x11memory_used_bytes\x18\f \x01(\x03R\x0fmemoryUsedBytes\x12'\n" +
	"\x0fworkloads_total\x18\r \x01(\x05R\x0eworkloadsTotal\x12+\n" +
	"\x11workloads_healthy\x18\x0e \x01(\x05R\x10workloadsHealthy\x12-\n" +
	"\x12workloads_degraded\x18\x0f \x01(\x05R\x11workloadsDegraded\x12'\n" +
	"\x0fworkloads_error\x18\x10 \x01(\x05R\x0eworkloadsError\"\xb2\a\n" +
	"\bWorkload\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x1d\n" +
	"\n" +
	"cluster_id\x18\x02 \x01(\tR\tclusterId\x12\x1c\n" +
	"\tnamespace\x18\x03 \x01(\tR\tnamespace\x12\x12\n" +
	"\x04name\x18\x04 \x01(\tR\x04name\x12\x12\n" +
	"\x04kind\x18\x05 \x01(\tR\x04kind\x12D\n" +
	"\x06labels\x18\x06 \x03(\v2,.admiral.api.cluster.v1.Workload.LabelsEntryR\x06labels\x12Q\n" +
	"\rhealth_status\x18\a \x01(\x0e2,.admiral.api.cluster.v1.WorkloadHealthStatusR\fhealthStatus\x12#\n" +
	"\rstatus_reason\x18\b \x01(\tR\fstatusReason\x12)\n" +
	"\x10replicas_desired\x18\t \x01(\x05R\x0freplicasDesired\x12%\n" +
	"\x0ereplicas_ready\x18\n" +
	" \x01(\x05R\rreplicasReady\x12-\n" +
	"\x12replicas_available\x18\v \x01(\x05R\x11replicasAvailable\x126\n" +
	"\x17cpu_requests_millicores\x18\f \x01(\x03R\x15cpuRequestsMillicores\x122\n" +
	"\x15cpu_limits_millicores\x18\r \x01(\x03R\x13cpuLimitsMillicores\x12.\n" +
	"\x13cpu_used_millicores\x18\x0e \x01(\x03R\x11cpuUsedMillicores\x122\n" +
	"\x15memory_requests_bytes\x18\x0f \x01(\x03R\x13memoryRequestsBytes\x12.\n" +
	"\x13memory_limits_bytes\x18\x10 \x01(\x03R\x11memoryLimitsBytes\x12*\n" +
	"\x11memory_used_bytes\x18\x11 \x01(\x03R\x0fmemoryUsedBytes\x12G\n" +
	"\n" +
	"containers\x18\x12 \x03(\v2'.admiral.api.cluster.v1.ContainerStatusR\n" +
	"containers\x12B\n" +
	"\x0flast_updated_at\x18\x13 \x01(\v2\x1a.google.protobuf.TimestampR\rlastUpdatedAt\x1a9\n" +
	"\vLabelsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\x8c\x01\n" +
	"\x0fContainerStatus\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x14\n" +
	"\x05image\x18\x02 \x01(\tR\x05image\x12#\n" +
	"\rrestart_count\x18\x03 \x01(\x05R\frestartCount\x12\x14\n" +
	"\x05state\x18\x04 \x01(\tR\x05state\x12\x14\n" +
	"\x05ready\x18\x05 \x01(\bR\x05ready\"W\n" +
	"\x0fObjectReference\x12\x12\n" +
	"\x04kind\x18\x01 \x01(\tR\x04kind\x12\x1c\n" +
	"\tnamespace\x18\x02 \x01(\tR\tnamespace\x12\x12\n" +
	"\x04name\x18\x03 \x01(\tR\x04name\"\xb8\x02\n" +
	"\rWorkloadEvent\x12\x10\n" +
	"\x03uid\x18\x01 \x01(\tR\x03uid\x12\x12\n" +
	"\x04type\x18\x02 \x01(\tR\x04type\x12\x16\n" +
	"\x06reason\x18\x03 \x01(\tR\x06reason\x12E\n" +
	"\tregarding\x18\x04 \x01(\v2'.admiral.api.cluster.v1.ObjectReferenceR\tregarding\x12\x18\n" +
	"\amessage\x18\x05 \x01(\tR\amessage\x129\n" +
	"\n" +
	"first_seen\x18\x06 \x01(\v2\x1a.google.protobuf.TimestampR\tfirstSeen\x127\n" +
	"\tlast_seen\x18\a \x01(\v2\x1a.google.protobuf.TimestampR\blastSeen\x12\x14\n" +
	"\x05count\x18\b \x01(\x05R\x05count\"\xd2\x01\n" +
	"\x14CreateClusterRequest\x12-\n" +
	"\fdisplay_name\x18\x01 \x01(\tB\n" +
	"\xbaH\ar\x05\x10\x01\x18\xff\x01R\vdisplayName\x12P\n" +
	"\x06labels\x18\x02 \x03(\v28.admiral.api.cluster.v1.CreateClusterRequest.LabelsEntryR\x06labels\x1a9\n" +
	"\vLabelsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"|\n" +
	"\x15CreateClusterResponse\x129\n" +
	"\acluster\x18\x01 \x01(\v2\x1f.admiral.api.cluster.v1.ClusterR\acluster\x12(\n" +
	"\x10plain_text_token\x18\x02 \x01(\tR\x0eplainTextToken\"<\n" +
	"\x11GetClusterRequest\x12'\n" +
	"\n" +
	"cluster_id\x18\x01 \x01(\tB\b\xbaH\x05r\x03\xb0\x01\x01R\tclusterId\"O\n" +
	"\x12GetClusterResponse\x129\n" +
	"\acluster\x18\x01 \x01(\v2\x1f.admiral.api.cluster.v1.ClusterR\acluster\"i\n" +
	"\x13ListClustersRequest\x12\x1b\n" +
	"\tpage_size\x18\x01 \x01(\x05R\bpageSize\x12\x1d\n" +
	"\n" +
	"page_token\x18\x02 \x01(\tR\tpageToken\x12\x16\n" +
	"\x06filter\x18\x03 \x01(\tR\x06filter\"{\n" +
	"\x14ListClustersResponse\x12;\n" +
	"\bclusters\x18\x01 \x03(\v2\x1f.admiral.api.cluster.v1.ClusterR\bclusters\x12&\n" +
	"\x0fnext_page_token\x18\x02 \x01(\tR\rnextPageToken\"\x96\x01\n" +
	"\x14UpdateClusterRequest\x12A\n" +
	"\acluster\x18\x01 \x01(\v2\x1f.admiral.api.cluster.v1.ClusterB\x06\xbaH\x03\xc8\x01\x01R\acluster\x12;\n" +
	"\vupdate_mask\x18\x02 \x01(\v2\x1a.google.protobuf.FieldMaskR\n" +
	"updateMask\"R\n" +
	"\x15UpdateClusterResponse\x129\n" +
	"\acluster\x18\x01 \x01(\v2\x1f.admiral.api.cluster.v1.ClusterR\acluster\"?\n" +
	"\x14DeleteClusterRequest\x12'\n" +
	"\n" +
	"cluster_id\x18\x01 \x01(\tB\b\xbaH\x05r\x03\xb0\x01\x01R\tclusterId\"\x17\n" +
	"\x15DeleteClusterResponse\"B\n" +
	"\x17GetClusterStatusRequest\x12'\n" +
	"\n" +
	"cluster_id\x18\x01 \x01(\tB\b\xbaH\x05r\x03\xb0\x01\x01R\tclusterId\"\xe8\x01\n" +
	"\x18GetClusterStatusResponse\x12P\n" +
	"\rhealth_status\x18\x01 \x01(\x0e2+.admiral.api.cluster.v1.ClusterHealthStatusR\fhealthStatus\x12=\n" +
	"\x06status\x18\x02 \x01(\v2%.admiral.api.cluster.v1.ClusterStatusR\x06status\x12;\n" +
	"\vreported_at\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampR\n" +
	"reportedAt\"\xce\x02\n" +
	"\x1aReportClusterStatusRequest\x12'\n" +
	"\n" +
	"cluster_id\x18\x01 \x01(\tB\b\xbaH\x05r\x03\xb0\x01\x01R\tclusterId\x12E\n" +
	"\x06status\x18\x02 \x01(\v2%.admiral.api.cluster.v1.ClusterStatusB\x06\xbaH\x03\xc8\x01\x01R\x06status\x12D\n" +
	"\tworkloads\x18\x03 \x03(\v2&.admiral.api.cluster.v1.WorkloadStatusR\tworkloads\x12=\n" +
	"\x06events\x18\x04 \x03(\v2%.admiral.api.cluster.v1.WorkloadEventR\x06events\x12;\n" +
	"\vreported_at\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampR\n" +
	"reportedAt\"\xa6\x06\n" +
	"\x0eWorkloadStatus\x12\x1c\n" +
	"\tnamespace\x18\x01 \x01(\tR\tnamespace\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12\x12\n" +
	"\x04kind\x18\x03 \x01(\tR\x04kind\x12J\n" +
	"\x06labels\x18\x04 \x03(\v22.admiral.api.cluster.v1.WorkloadStatus.LabelsEntryR\x06labels\x12)\n" +
	"\x10replicas_desired\x18\x05 \x01(\x05R\x0freplicasDesired\x12%\n" +
	"\x0ereplicas_ready\x18\x06 \x01(\x05R\rreplicasReady\x12-\n" +
	"\x12replicas_available\x18\a \x01(\x05R\x11replicasAvailable\x126\n" +
	"\x17cpu_requests_millicores\x18\b \x01(\x03R\x15cpuRequestsMillicores\x122\n" +
	"\x15cpu_limits_millicores\x18\t \x01(\x03R\x13cpuLimitsMillicores\x12.\n" +
	"\x13cpu_used_millicores\x18\n" +
	" \x01(\x03R\x11cpuUsedMillicores\x122\n" +
	"\x15memory_requests_bytes\x18\v \x01(\x03R\x13memoryRequestsBytes\x12.\n" +
	"\x13memory_limits_bytes\x18\f \x01(\x03R\x11memoryLimitsBytes\x12*\n" +
	"\x11memory_used_bytes\x18\r \x01(\x03R\x0fmemoryUsedBytes\x12Q\n" +
	"\rhealth_status\x18\x0e \x01(\x0e2,.admiral.api.cluster.v1.WorkloadHealthStatusR\fhealthStatus\x12G\n" +
	"\n" +
	"containers\x18\x0f \x03(\v2'.admiral.api.cluster.v1.ContainerStatusR\n" +
	"containers\x1a9\n" +
	"\vLabelsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"[\n" +
	"\x1bReportClusterStatusResponse\x12\x10\n" +
	"\x03ack\x18\x01 \x01(\bR\x03ack\x12*\n" +
	"\x11next_push_seconds\x18\x02 \x01(\x05R\x0fnextPushSeconds\"\x93\x01\n" +
	"\x14ListWorkloadsRequest\x12'\n" +
	"\n" +
	"cluster_id\x18\x01 \x01(\tB\b\xbaH\x05r\x03\xb0\x01\x01R\tclusterId\x12\x1b\n" +
	"\tpage_size\x18\x02 \x01(\x05R\bpageSize\x12\x1d\n" +
	"\n" +
	"page_token\x18\x03 \x01(\tR\tpageToken\x12\x16\n" +
	"\x06filter\x18\x04 \x01(\tR\x06filter\"\x7f\n" +
	"\x15ListWorkloadsResponse\x12>\n" +
	"\tworkloads\x18\x01 \x03(\v2 .admiral.api.cluster.v1.WorkloadR\tworkloads\x12&\n" +
	"\x0fnext_page_token\x18\x02 \x01(\tR\rnextPageToken\"\xc9\x01\n" +
	"\x1bReportWorkloadStatusRequest\x12'\n" +
	"\n" +
	"cluster_id\x18\x01 \x01(\tB\b\xbaH\x05r\x03\xb0\x01\x01R\tclusterId\x12D\n" +
	"\tworkloads\x18\x02 \x03(\v2&.admiral.api.cluster.v1.WorkloadStatusR\tworkloads\x12;\n" +
	"\vreported_at\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampR\n" +
	"reportedAt\"0\n" +
	"\x1cReportWorkloadStatusResponse\x12\x10\n" +
	"\x03ack\x18\x01 \x01(\bR\x03ack\"\xae\x01\n" +
	"\x19CreateClusterTokenRequest\x12'\n" +
	"\n" +
	"cluster_id\x18\x01 \x01(\tB\b\xbaH\x05r\x03\xb0\x01\x01R\tclusterId\x12-\n" +
	"\fdisplay_name\x18\x02 \x01(\tB\n" +
	"\xbaH\ar\x05\x10\x01\x18\xff\x01R\vdisplayName\x129\n" +
	"\n" +
	"expires_at\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampR\texpiresAt\"\x92\x01\n" +
	"\x1aCreateClusterTokenResponse\x12J\n" +
	"\faccess_token\x18\x01 \x01(\v2'.admiral.api.accesstoken.v1.AccessTokenR\vaccessToken\x12(\n" +
	"\x10plain_text_token\x18\x02 \x01(\tR\x0eplainTextToken\"\x97\x01\n" +
	"\x18ListClusterTokensRequest\x12'\n" +
	"\n" +
	"cluster_id\x18\x01 \x01(\tB\b\xbaH\x05r\x03\xb0\x01\x01R\tclusterId\x12\x1b\n" +
	"\tpage_size\x18\x02 \x01(\x05R\bpageSize\x12\x1d\n" +
	"\n" +
	"page_token\x18\x03 \x01(\tR\tpageToken\x12\x16\n" +
	"\x06filter\x18\x04 \x01(\tR\x06filter\"\x91\x01\n" +
	"\x19ListClusterTokensResponse\x12L\n" +
	"\raccess_tokens\x18\x01 \x03(\v2'.admiral.api.accesstoken.v1.AccessTokenR\faccessTokens\x12&\n" +
	"\x0fnext_page_token\x18\x02 \x01(\tR\rnextPageToken\"f\n" +
	"\x16GetClusterTokenRequest\x12'\n" +
	"\n" +
	"cluster_id\x18\x01 \x01(\tB\b\xbaH\x05r\x03\xb0\x01\x01R\tclusterId\x12#\n" +
	"\btoken_id\x18\x02 \x01(\tB\b\xbaH\x05r\x03\xb0\x01\x01R\atokenId\"e\n" +
	"\x17GetClusterTokenResponse\x12J\n" +
	"\faccess_token\x18\x01 \x01(\v2'.admiral.api.accesstoken.v1.AccessTokenR\vaccessToken\"i\n" +
	"\x19RevokeClusterTokenRequest\x12'\n" +
	"\n" +
	"cluster_id\x18\x01 \x01(\tB\b\xbaH\x05r\x03\xb0\x01\x01R\tclusterId\x12#\n" +
	"\btoken_id\x18\x02 \x01(\tB\b\xbaH\x05r\x03\xb0\x01\x01R\atokenId\"h\n" +
	"\x1aRevokeClusterTokenResponse\x12J\n" +
	"\faccess_token\x18\x01 \x01(\v2'.admiral.api.accesstoken.v1.AccessTokenR\vaccessToken*\xee\x01\n" +
	"\x13ClusterHealthStatus\x12%\n" +
	"!CLUSTER_HEALTH_STATUS_UNSPECIFIED\x10\x00\x12!\n" +
	"\x1dCLUSTER_HEALTH_STATUS_PENDING\x10\x01\x12!\n" +
	"\x1dCLUSTER_HEALTH_STATUS_HEALTHY\x10\x02\x12\"\n" +
	"\x1eCLUSTER_HEALTH_STATUS_DEGRADED\x10\x03\x12\x1f\n" +
	"\x1bCLUSTER_HEALTH_STATUS_ERROR\x10\x04\x12%\n" +
	"!CLUSTER_HEALTH_STATUS_UNREACHABLE\x10\x05*\xa9\x01\n" +
	"\x14WorkloadHealthStatus\x12&\n" +
	"\"WORKLOAD_HEALTH_STATUS_UNSPECIFIED\x10\x00\x12\"\n" +
	"\x1eWORKLOAD_HEALTH_STATUS_HEALTHY\x10\x01\x12#\n" +
	"\x1fWORKLOAD_HEALTH_STATUS_DEGRADED\x10\x02\x12 \n" +
	"\x1cWORKLOAD_HEALTH_STATUS_ERROR\x10\x032\xae\x12\n" +
	"\n" +
	"ClusterAPI\x12\x99\x01\n" +
	"\rCreateCluster\x12,.admiral.api.cluster.v1.CreateClusterRequest\x1a-.admiral.api.cluster.v1.CreateClusterResponse\"+\x82\xb5\x18\x10\n" +
	"\x0eclusters:write\x82\xd3\xe4\x93\x02\x11:\x01*\"\f/v1/clusters\x12\x99\x01\n" +
	"\n" +
	"GetCluster\x12).admiral.api.cluster.v1.GetClusterRequest\x1a*.admiral.api.cluster.v1.GetClusterResponse\"4\x82\xb5\x18\x0f\n" +
	"\rclusters:read\x82\xd3\xe4\x93\x02\x1b\x12\x19/v1/clusters/{cluster_id}\x12\xb2\x01\n" +
	"\x10GetClusterStatus\x12/.admiral.api.cluster.v1.GetClusterStatusRequest\x1a0.admiral.api.cluster.v1.GetClusterStatusResponse\";\x82\xb5\x18\x0f\n" +
	"\rclusters:read\x82\xd3\xe4\x93\x02\"\x12 /v1/clusters/{cluster_id}/status\x12\x92\x01\n" +
	"\fListClusters\x12+.admiral.api.cluster.v1.ListClustersRequest\x1a,.admiral.api.cluster.v1.ListClustersResponse\"'\x82\xb5\x18\x0f\n" +
	"\rclusters:read\x82\xd3\xe4\x93\x02\x0e\x12\f/v1/clusters\x12\xa6\x01\n" +
	"\rUpdateCluster\x12,.admiral.api.cluster.v1.UpdateClusterRequest\x1a-.admiral.api.cluster.v1.UpdateClusterResponse\"8\x82\xb5\x18\x10\n" +
	"\x0eclusters:write\x82\xd3\xe4\x93\x02\x1e:\x01*2\x19/v1/clusters/{cluster.id}\x12\xa3\x01\n" +
	"\rDeleteCluster\x12,.admiral.api.cluster.v1.DeleteClusterRequest\x1a-.admiral.api.cluster.v1.DeleteClusterResponse\"5\x82\xb5\x18\x10\n" +
	"\x0eclusters:write\x82\xd3\xe4\x93\x02\x1b*\x19/v1/clusters/{cluster_id}\x12\xbc\x01\n" +
	"\x12CreateClusterToken\x121.admiral.api.cluster.v1.CreateClusterTokenRequest\x1a2.admiral.api.cluster.v1.CreateClusterTokenResponse\"?\x82\xb5\x18\x10\n" +
	"\x0eclusters:write\x82\xd3\xe4\x93\x02%:\x01*\" /v1/clusters/{cluster_id}/tokens\x12\xb5\x01\n" +
	"\x11ListClusterTokens\x120.admiral.api.cluster.v1.ListClusterTokensRequest\x1a1.admiral.api.cluster.v1.ListClusterTokensResponse\";\x82\xb5\x18\x0f\n" +
	"\rclusters:read\x82\xd3\xe4\x93\x02\"\x12 /v1/clusters/{cluster_id}/tokens\x12\xba\x01\n" +
	"\x0fGetClusterToken\x12..admiral.api.cluster.v1.GetClusterTokenRequest\x1a/.admiral.api.cluster.v1.GetClusterTokenResponse\"F\x82\xb5\x18\x0f\n" +
	"\rclusters:read\x82\xd3\xe4\x93\x02-\x12+/v1/clusters/{cluster_id}/tokens/{token_id}\x12\xce\x01\n" +
	"\x12RevokeClusterToken\x121.admiral.api.cluster.v1.RevokeClusterTokenRequest\x1a2.admiral.api.cluster.v1.RevokeClusterTokenResponse\"Q\x82\xb5\x18\x10\n" +
	"\x0eclusters:write\x82\xd3\xe4\x93\x027:\x01*\"2/v1/clusters/{cluster_id}/tokens/{token_id}/revoke\x12\xc5\x01\n" +
	"\x13ReportClusterStatus\x122.admiral.api.cluster.v1.ReportClusterStatusRequest\x1a3.admiral.api.cluster.v1.ReportClusterStatusResponse\"E\x82\xb5\x18\x16\n" +
	"\x0fclusters:status\x12\x03agt\x82\xd3\xe4\x93\x02%:\x01*\" /v1/clusters/{cluster_id}/status\x12\xac\x01\n" +
	"\rListWorkloads\x12,.admiral.api.cluster.v1.ListWorkloadsRequest\x1a-.admiral.api.cluster.v1.ListWorkloadsResponse\">\x82\xb5\x18\x0f\n" +
	"\rclusters:read\x82\xd3\xe4\x93\x02%\x12#/v1/clusters/{cluster_id}/workloads\x12\xd2\x01\n" +
	"\x14ReportWorkloadStatus\x123.admiral.api.cluster.v1.ReportWorkloadStatusRequest\x1a4.admiral.api.cluster.v1.ReportWorkloadStatusResponse\"O\x82\xb5\x18\x16\n" +
	"\x0fclusters:status\x12\x03agt\x82\xd3\xe4\x93\x02/:\x01*\"*/v1/clusters/{cluster_id}/workloads/statusB\xd3\x01\n" +
	"\x1acom.admiral.api.cluster.v1B\fClusterProtoP\x01Z,go.admiral.io/sdk/proto/cluster/v1;clusterv1\xa2\x02\x03AAC\xaa\x02\x16Admiral.Api.Cluster.V1\xca\x02\x16Admiral\\Api\\Cluster\\V1\xe2\x02\"Admiral\\Api\\Cluster\\V1\\GPBMetadata\xea\x02\x19Admiral::Api::Cluster::V1b\x06proto3"

var (
	file_cluster_v1_cluster_proto_rawDescOnce sync.Once
	file_cluster_v1_cluster_proto_rawDescData []byte
)

func file_cluster_v1_cluster_proto_rawDescGZIP() []byte {
	file_cluster_v1_cluster_proto_rawDescOnce.Do(func() {
		file_cluster_v1_cluster_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_cluster_v1_cluster_proto_rawDesc), len(file_cluster_v1_cluster_proto_rawDesc)))
	})
	return file_cluster_v1_cluster_proto_rawDescData
}

var file_cluster_v1_cluster_proto_enumTypes = make([]protoimpl.EnumInfo, 2)
var file_cluster_v1_cluster_proto_msgTypes = make([]protoimpl.MessageInfo, 37)
var file_cluster_v1_cluster_proto_goTypes = []any{
	(ClusterHealthStatus)(0),             // 0: admiral.api.cluster.v1.ClusterHealthStatus
	(WorkloadHealthStatus)(0),            // 1: admiral.api.cluster.v1.WorkloadHealthStatus
	(*Cluster)(nil),                      // 2: admiral.api.cluster.v1.Cluster
	(*ClusterStatus)(nil),                // 3: admiral.api.cluster.v1.ClusterStatus
	(*Workload)(nil),                     // 4: admiral.api.cluster.v1.Workload
	(*ContainerStatus)(nil),              // 5: admiral.api.cluster.v1.ContainerStatus
	(*ObjectReference)(nil),              // 6: admiral.api.cluster.v1.ObjectReference
	(*WorkloadEvent)(nil),                // 7: admiral.api.cluster.v1.WorkloadEvent
	(*CreateClusterRequest)(nil),         // 8: admiral.api.cluster.v1.CreateClusterRequest
	(*CreateClusterResponse)(nil),        // 9: admiral.api.cluster.v1.CreateClusterResponse
	(*GetClusterRequest)(nil),            // 10: admiral.api.cluster.v1.GetClusterRequest
	(*GetClusterResponse)(nil),           // 11: admiral.api.cluster.v1.GetClusterResponse
	(*ListClustersRequest)(nil),          // 12: admiral.api.cluster.v1.ListClustersRequest
	(*ListClustersResponse)(nil),         // 13: admiral.api.cluster.v1.ListClustersResponse
	(*UpdateClusterRequest)(nil),         // 14: admiral.api.cluster.v1.UpdateClusterRequest
	(*UpdateClusterResponse)(nil),        // 15: admiral.api.cluster.v1.UpdateClusterResponse
	(*DeleteClusterRequest)(nil),         // 16: admiral.api.cluster.v1.DeleteClusterRequest
	(*DeleteClusterResponse)(nil),        // 17: admiral.api.cluster.v1.DeleteClusterResponse
	(*GetClusterStatusRequest)(nil),      // 18: admiral.api.cluster.v1.GetClusterStatusRequest
	(*GetClusterStatusResponse)(nil),     // 19: admiral.api.cluster.v1.GetClusterStatusResponse
	(*ReportClusterStatusRequest)(nil),   // 20: admiral.api.cluster.v1.ReportClusterStatusRequest
	(*WorkloadStatus)(nil),               // 21: admiral.api.cluster.v1.WorkloadStatus
	(*ReportClusterStatusResponse)(nil),  // 22: admiral.api.cluster.v1.ReportClusterStatusResponse
	(*ListWorkloadsRequest)(nil),         // 23: admiral.api.cluster.v1.ListWorkloadsRequest
	(*ListWorkloadsResponse)(nil),        // 24: admiral.api.cluster.v1.ListWorkloadsResponse
	(*ReportWorkloadStatusRequest)(nil),  // 25: admiral.api.cluster.v1.ReportWorkloadStatusRequest
	(*ReportWorkloadStatusResponse)(nil), // 26: admiral.api.cluster.v1.ReportWorkloadStatusResponse
	(*CreateClusterTokenRequest)(nil),    // 27: admiral.api.cluster.v1.CreateClusterTokenRequest
	(*CreateClusterTokenResponse)(nil),   // 28: admiral.api.cluster.v1.CreateClusterTokenResponse
	(*ListClusterTokensRequest)(nil),     // 29: admiral.api.cluster.v1.ListClusterTokensRequest
	(*ListClusterTokensResponse)(nil),    // 30: admiral.api.cluster.v1.ListClusterTokensResponse
	(*GetClusterTokenRequest)(nil),       // 31: admiral.api.cluster.v1.GetClusterTokenRequest
	(*GetClusterTokenResponse)(nil),      // 32: admiral.api.cluster.v1.GetClusterTokenResponse
	(*RevokeClusterTokenRequest)(nil),    // 33: admiral.api.cluster.v1.RevokeClusterTokenRequest
	(*RevokeClusterTokenResponse)(nil),   // 34: admiral.api.cluster.v1.RevokeClusterTokenResponse
	nil,                                  // 35: admiral.api.cluster.v1.Cluster.LabelsEntry
	nil,                                  // 36: admiral.api.cluster.v1.Workload.LabelsEntry
	nil,                                  // 37: admiral.api.cluster.v1.CreateClusterRequest.LabelsEntry
	nil,                                  // 38: admiral.api.cluster.v1.WorkloadStatus.LabelsEntry
	(*timestamppb.Timestamp)(nil),        // 39: google.protobuf.Timestamp
	(*fieldmaskpb.FieldMask)(nil),        // 40: google.protobuf.FieldMask
	(*v1.AccessToken)(nil),               // 41: admiral.api.accesstoken.v1.AccessToken
}
var file_cluster_v1_cluster_proto_depIdxs = []int32{
	35, // 0: admiral.api.cluster.v1.Cluster.labels:type_name -> admiral.api.cluster.v1.Cluster.LabelsEntry
	0,  // 1: admiral.api.cluster.v1.Cluster.health_status:type_name -> admiral.api.cluster.v1.ClusterHealthStatus
	39, // 2: admiral.api.cluster.v1.Cluster.created_at:type_name -> google.protobuf.Timestamp
	39, // 3: admiral.api.cluster.v1.Cluster.updated_at:type_name -> google.protobuf.Timestamp
	36, // 4: admiral.api.cluster.v1.Workload.labels:type_name -> admiral.api.cluster.v1.Workload.LabelsEntry
	1,  // 5: admiral.api.cluster.v1.Workload.health_status:type_name -> admiral.api.cluster.v1.WorkloadHealthStatus
	5,  // 6: admiral.api.cluster.v1.Workload.containers:type_name -> admiral.api.cluster.v1.ContainerStatus
	39, // 7: admiral.api.cluster.v1.Workload.last_updated_at:type_name -> google.protobuf.Timestamp
	6,  // 8: admiral.api.cluster.v1.WorkloadEvent.regarding:type_name -> admiral.api.cluster.v1.ObjectReference
	39, // 9: admiral.api.cluster.v1.WorkloadEvent.first_seen:type_name -> google.protobuf.Timestamp
	39, // 10: admiral.api.cluster.v1.WorkloadEvent.last_seen:type_name -> google.protobuf.Timestamp
	37, // 11: admiral.api.cluster.v1.CreateClusterRequest.labels:type_name -> admiral.api.cluster.v1.CreateClusterRequest.LabelsEntry
	2,  // 12: admiral.api.cluster.v1.CreateClusterResponse.cluster:type_name -> admiral.api.cluster.v1.Cluster
	2,  // 13: admiral.api.cluster.v1.GetClusterResponse.cluster:type_name -> admiral.api.cluster.v1.Cluster
	2,  // 14: admiral.api.cluster.v1.ListClustersResponse.clusters:type_name -> admiral.api.cluster.v1.Cluster
	2,  // 15: admiral.api.cluster.v1.UpdateClusterRequest.cluster:type_name -> admiral.api.cluster.v1.Cluster
	40, // 16: admiral.api.cluster.v1.UpdateClusterRequest.update_mask:type_name -> google.protobuf.FieldMask
	2,  // 17: admiral.api.cluster.v1.UpdateClusterResponse.cluster:type_name -> admiral.api.cluster.v1.Cluster
	0,  // 18: admiral.api.cluster.v1.GetClusterStatusResponse.health_status:type_name -> admiral.api.cluster.v1.ClusterHealthStatus
	3,  // 19: admiral.api.cluster.v1.GetClusterStatusResponse.status:type_name -> admiral.api.cluster.v1.ClusterStatus
	39, // 20: admiral.api.cluster.v1.GetClusterStatusResponse.reported_at:type_name -> google.protobuf.Timestamp
	3,  // 21: admiral.api.cluster.v1.ReportClusterStatusRequest.status:type_name -> admiral.api.cluster.v1.ClusterStatus
	21, // 22: admiral.api.cluster.v1.ReportClusterStatusRequest.workloads:type_name -> admiral.api.cluster.v1.WorkloadStatus
	7,  // 23: admiral.api.cluster.v1.ReportClusterStatusRequest.events:type_name -> admiral.api.cluster.v1.WorkloadEvent
	39, // 24: admiral.api.cluster.v1.ReportClusterStatusRequest.reported_at:type_name -> google.protobuf.Timestamp
	38, // 25: admiral.api.cluster.v1.WorkloadStatus.labels:type_name -> admiral.api.cluster.v1.WorkloadStatus.LabelsEntry
	1,  // 26: admiral.api.cluster.v1.WorkloadStatus.health_status:type_name -> admiral.api.cluster.v1.WorkloadHealthStatus
	5,  // 27: admiral.api.cluster.v1.WorkloadStatus.containers:type_name -> admiral.api.cluster.v1.ContainerStatus
	4,  // 28: admiral.api.cluster.v1.ListWorkloadsResponse.workloads:type_name -> admiral.api.cluster.v1.Workload
	21, // 29: admiral.api.cluster.v1.ReportWorkloadStatusRequest.workloads:type_name -> admiral.api.cluster.v1.WorkloadStatus
	39, // 30: admiral.api.cluster.v1.ReportWorkloadStatusRequest.reported_at:type_name -> google.protobuf.Timestamp
	39, // 31: admiral.api.cluster.v1.CreateClusterTokenRequest.expires_at:type_name -> google.protobuf.Timestamp
	41, // 32: admiral.api.cluster.v1.CreateClusterTokenResponse.access_token:type_name -> admiral.api.accesstoken.v1.AccessToken
	41, // 33: admiral.api.cluster.v1.ListClusterTokensResponse.access_tokens:type_name -> admiral.api.accesstoken.v1.AccessToken
	41, // 34: admiral.api.cluster.v1.GetClusterTokenResponse.access_token:type_name -> admiral.api.accesstoken.v1.AccessToken
	41, // 35: admiral.api.cluster.v1.RevokeClusterTokenResponse.access_token:type_name -> admiral.api.accesstoken.v1.AccessToken
	8,  // 36: admiral.api.cluster.v1.ClusterAPI.CreateCluster:input_type -> admiral.api.cluster.v1.CreateClusterRequest
	10, // 37: admiral.api.cluster.v1.ClusterAPI.GetCluster:input_type -> admiral.api.cluster.v1.GetClusterRequest
	18, // 38: admiral.api.cluster.v1.ClusterAPI.GetClusterStatus:input_type -> admiral.api.cluster.v1.GetClusterStatusRequest
	12, // 39: admiral.api.cluster.v1.ClusterAPI.ListClusters:input_type -> admiral.api.cluster.v1.ListClustersRequest
	14, // 40: admiral.api.cluster.v1.ClusterAPI.UpdateCluster:input_type -> admiral.api.cluster.v1.UpdateClusterRequest
	16, // 41: admiral.api.cluster.v1.ClusterAPI.DeleteCluster:input_type -> admiral.api.cluster.v1.DeleteClusterRequest
	27, // 42: admiral.api.cluster.v1.ClusterAPI.CreateClusterToken:input_type -> admiral.api.cluster.v1.CreateClusterTokenRequest
	29, // 43: admiral.api.cluster.v1.ClusterAPI.ListClusterTokens:input_type -> admiral.api.cluster.v1.ListClusterTokensRequest
	31, // 44: admiral.api.cluster.v1.ClusterAPI.GetClusterToken:input_type -> admiral.api.cluster.v1.GetClusterTokenRequest
	33, // 45: admiral.api.cluster.v1.ClusterAPI.RevokeClusterToken:input_type -> admiral.api.cluster.v1.RevokeClusterTokenRequest
	20, // 46: admiral.api.cluster.v1.ClusterAPI.ReportClusterStatus:input_type -> admiral.api.cluster.v1.ReportClusterStatusRequest
	23, // 47: admiral.api.cluster.v1.ClusterAPI.ListWorkloads:input_type -> admiral.api.cluster.v1.ListWorkloadsRequest
	25, // 48: admiral.api.cluster.v1.ClusterAPI.ReportWorkloadStatus:input_type -> admiral.api.cluster.v1.ReportWorkloadStatusRequest
	9,  // 49: admiral.api.cluster.v1.ClusterAPI.CreateCluster:output_type -> admiral.api.cluster.v1.CreateClusterResponse
	11, // 50: admiral.api.cluster.v1.ClusterAPI.GetCluster:output_type -> admiral.api.cluster.v1.GetClusterResponse
	19, // 51: admiral.api.cluster.v1.ClusterAPI.GetClusterStatus:output_type -> admiral.api.cluster.v1.GetClusterStatusResponse
	13, // 52: admiral.api.cluster.v1.ClusterAPI.ListClusters:output_type -> admiral.api.cluster.v1.ListClustersResponse
	15, // 53: admiral.api.cluster.v1.ClusterAPI.UpdateCluster:output_type -> admiral.api.cluster.v1.UpdateClusterResponse
	17, // 54: admiral.api.cluster.v1.ClusterAPI.DeleteCluster:output_type -> admiral.api.cluster.v1.DeleteClusterResponse
	28, // 55: admiral.api.cluster.v1.ClusterAPI.CreateClusterToken:output_type -> admiral.api.cluster.v1.CreateClusterTokenResponse
	30, // 56: admiral.api.cluster.v1.ClusterAPI.ListClusterTokens:output_type -> admiral.api.cluster.v1.ListClusterTokensResponse
	32, // 57: admiral.api.cluster.v1.ClusterAPI.GetClusterToken:output_type -> admiral.api.cluster.v1.GetClusterTokenResponse
	34, // 58: admiral.api.cluster.v1.ClusterAPI.RevokeClusterToken:output_type -> admiral.api.cluster.v1.RevokeClusterTokenResponse
	22, // 59: admiral.api.cluster.v1.ClusterAPI.ReportClusterStatus:output_type -> admiral.api.cluster.v1.ReportClusterStatusResponse
	24, // 60: admiral.api.cluster.v1.ClusterAPI.ListWorkloads:output_type -> admiral.api.cluster.v1.ListWorkloadsResponse
	26, // 61: admiral.api.cluster.v1.ClusterAPI.ReportWorkloadStatus:output_type -> admiral.api.cluster.v1.ReportWorkloadStatusResponse
	49, // [49:62] is the sub-list for method output_type
	36, // [36:49] is the sub-list for method input_type
	36, // [36:36] is the sub-list for extension type_name
	36, // [36:36] is the sub-list for extension extendee
	0,  // [0:36] is the sub-list for field type_name
}

func init() { file_cluster_v1_cluster_proto_init() }
func file_cluster_v1_cluster_proto_init() {
	if File_cluster_v1_cluster_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_cluster_v1_cluster_proto_rawDesc), len(file_cluster_v1_cluster_proto_rawDesc)),
			NumEnums:      2,
			NumMessages:   37,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_cluster_v1_cluster_proto_goTypes,
		DependencyIndexes: file_cluster_v1_cluster_proto_depIdxs,
		EnumInfos:         file_cluster_v1_cluster_proto_enumTypes,
		MessageInfos:      file_cluster_v1_cluster_proto_msgTypes,
	}.Build()
	File_cluster_v1_cluster_proto = out.File
	file_cluster_v1_cluster_proto_goTypes = nil
	file_cluster_v1_cluster_proto_depIdxs = nil
}
